service: ${{file(./env.json):SERVERLESS_SERVICE_NAME}}
frameworkVersion: ">=1.5.0 <2.0.0"

plugins:
  - serverless-resources-env
  # - serverless-dynamodb-ttl
  # - serverless-plugin-write-env-vars
  # - serverless-plugin-include-dependencies
  # - serverless-dynamodb-local
  # - serverless-offline

package:
  exclude:
    - .git/**
    - .serverless/**
    - scripts/**
    - node_modules/**
    - simulate/**
    - ./**/*.log

custom:
  prefix: ${{self:service}}-${{self:provider.stage}}-
  defaultStage: dev
  stage: ${{opt:stage, self:custom.defaultStage}}
  accountId: ${{file(./env.json):ACCOUNT_ID}}
  pushServer: https://push1.tradle.io
  blockchain: testnet
  METADATA_PREFIX: ${{file(./project/lib/constants.json):METADATA_PREFIX}}
  IDENTITY_KEYS_KEY: ${{file(./project/lib/constants.json):IDENTITY_KEYS_KEY}}
  SECRETS_BUCKET: ${{self:custom.prefix}}secrets
  OBJECTS_BUCKET: ${{self:custom.prefix}}objects
  PRIVATE_CONF_BUCKET: ${{self:custom.prefix}}private-conf
  PUBLIC_CONF_BUCKET: ${{self:custom.prefix}}public-conf
  props:
    author: ${{self:custom.METADATA_PREFIX}}author
    recipient: ${{self:custom.METADATA_PREFIX}}recipient
    time: ${{self:custom.METADATA_PREFIX}}time
    link: ${{self:custom.METADATA_PREFIX}}link
    # seq: seq
  # writeEnvVars:
  #   SERVERLESS_STAGE: ${{self:custom.stage}}
  #   SERVERLESS_SERVICE_NAME: ${{self:service}}
  #   SERVERLESS_PREFIX: ${{self:service}}-${{self:provider.stage}}

#   secrets: ${file(secrets.${opt:stage, self:provider.stage}.yml)}
  # deployBucket: io.tradle.aws.code
  # dynamodb:
  #   start:
  #     port: 8000
  #     inMemory: true
  #     migration: true
  #   migration:
  #     dir: offline/migrations

provider:
  # avoid some bugs in serverless
  versionFunctions: false
  variableSyntax: '\${{([\s\S]+?)}}'
  # variableSyntax: "\${{([\s\S]+?)}}"
  name: aws
  runtime: nodejs6.10
  profile: serverless
  stage: ${{self:custom.stage}}
  region: us-east-1
  memorySize: 128
  # deploymentBucket: io.tradle.${{self:provider.region}.deploys # Overwrite the default deployment bucket
  environment:
    BLOCKCHAIN: ${{self:custom.blockchain}}
    DEBUG: tradle:*
    SERVERLESS_STAGE: ${{self:custom.stage}}
    SERVERLESS_SERVICE_NAME: ${{self:service}}
    PUSH_SERVER_URL: ${{self:custom.pushServer}}
  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
        - dynamodb:BatchWriteItem
        - dynamodb:DescribeStream
        - dynamodb:GetRecords
        - dynamodb:GetShardIterator
        - dynamodb:ListStreams
      Resource:
        - "arn:aws:dynamodb:${{self:provider.region}}:${{self:custom.accountId}}:table/EventsTable"
        # - "arn:aws:dynamodb:${{self:provider.region}}:${{self:custom.accountId}}:table/MessagesTable"
        - "arn:aws:dynamodb:${{self:provider.region}}:${{self:custom.accountId}}:table/PresenceTable"
        - "arn:aws:dynamodb:${{self:provider.region}}:${{self:custom.accountId}}:table/CursorTable"
        - "arn:aws:dynamodb:${{self:provider.region}}:${{self:custom.accountId}}:table/WebhooksTable"
        - "arn:aws:dynamodb:${{self:provider.region}}:${{self:custom.accountId}}:table/InboxTable"
        - "arn:aws:dynamodb:${{self:provider.region}}:${{self:custom.accountId}}:table/InboxTable/index/*"
        - "arn:aws:dynamodb:${{self:provider.region}}:${{self:custom.accountId}}:table/OutboxTable"
        - "arn:aws:dynamodb:${{self:provider.region}}:${{self:custom.accountId}}:table/PubKeysTable"
        - "arn:aws:dynamodb:${{self:provider.region}}:${{self:custom.accountId}}:table/PubKeysTable/index/*"

    # allow access to bucket
    # TODO: give access only to the lambdas that need it
    - Effect: Allow
      Action:
        - s3:ListBucket
        - s3:PutObject
        - s3:GetObject
      Resource:
        - "arn:aws:s3:::${{self:custom.PUBLIC_CONF_BUCKET}}/*"
        - "arn:aws:s3:::${{self:custom.OBJECTS_BUCKET}}/*"
        - "arn:aws:s3:::${{self:custom.SECRETS_BUCKET}}/*"

    # REMOVE in prod
    # allow access to buckets from the console
    - Effect: Allow
      Action:
        - s3:GetBucketLocation
        - s3:ListAllMyBuckets
      Resource: "arn:aws:s3:::*"

    # allow lambdas to call each other
    # TODO: make this more fine grained
    - Effect: Allow
      Action:
        - lambda:InvokeFunction
        - lambda:InvokeAsync
      Resource: "*"

    # Iot
    - Effect: Allow
      Action: ["iot:Connect", "iot:Subscribe", "iot:Publish", "iot:Receive", "iot:DescribeEndpoint"]
      Resource: ["*"]

    # gen Iot temp credentials (lambda: preauth)
    - Effect: "Allow"
      Action:
        - sts:AssumeRole
      Resource: "*"

      # Resource: "*"
   # - Effect: "Allow"
   #   Action:
   #     - "s3:GetObject"
   #   Resource: { "Fn::Join" : ["", ["arn:aws:s3:::", { "Ref" : "ServerlessDeploymentBucket" } ] ]  }
   # - Effect: "Allow"
   #   Action:
   #     - "s3:PutObject"
   #   Resource:
   #     Fn::Join:
   #       - ""
   #       - - "arn:aws:s3:::"
   #         - "Ref" : "ServerlessDeploymentBucket"
   #         - "/*"

functions:
  preauth:
    handler: project/lib/lambda/http/preauth.handler
    memorySize: 1024
    events:
      - http:
          path: tradle/preauth
          method: post
          cors: true
    environment:
      DEBUG: tradle:*
    custom:
      env-resources:
        - ObjectsBucket
        - PublicConfBucket
        - EventsTable
        - PresenceTable
        - PubKeysTable
        - InboxTable
        - OutboxTable
        - SealsTable
        - IotClientRole
  auth:
    handler: project/lib/lambda/http/auth.handler
    memorySize: 1024
    events:
      - http:
          path: tradle/auth
          method: post
          cors: true
    environment:
      DEBUG: tradle:*
    custom:
      env-resources:
        - ObjectsBucket
        - PublicConfBucket
        - EventsTable
        - PresenceTable
        - PubKeysTable
        - InboxTable
        - OutboxTable
        - SealsTable
        - IotClientRole
  # createevent:
  #   handler: project/lib/lambda/createevent.handler
  #   memorySize: 512

  inbox2events:
    handler: project/lib/lambda/inbox-events.handler
    timeout: 60
    memorySize: 512
    environment:
      DEBUG: tradle:*
    custom:
      env-resources:
        - ObjectsBucket
        - SecretsBucket
        - EventsTable
        - PresenceTable
        - PubKeysTable
        - InboxTable
        - OutboxTable
        - SealsTable
        - PublicConfBucket
    events:
      - stream:
          type: dynamodb
          batchSize: 100
          startingPosition: TRIM_HORIZON
          arn:
            Fn::GetAtt:
              - InboxTable
              - StreamArn

  outbox2events:
    handler: project/lib/lambda/outbox-events.handler
    timeout: 60
    memorySize: 512
    environment:
      DEBUG: tradle:*
    custom:
      env-resources:
        - ObjectsBucket
        - SecretsBucket
        - EventsTable
        - PresenceTable
        - PubKeysTable
        - InboxTable
        - OutboxTable
        - SealsTable
        - PublicConfBucket
    events:
      - stream:
          type: dynamodb
          batchSize: 100
          startingPosition: TRIM_HORIZON
          arn:
            Fn::GetAtt:
              - OutboxTable
              - StreamArn
  # log:
  #   handler: project/lib/lambda/log.handler
  #   # package:
  #   #   exclude:
  #   #     - node_modules/
  #   environment:
  #     DEBUG: tradle:*
  #   custom:
  #     env-resources:
  #       - SecretsBucket
  #       - ObjectsBucket
  #       - PresenceTable
  #       - EventsTable
  #       - PubKeysTable
  #       - InboxTable
  #       - OutboxTable

    # events:
  #     - stream:
  #         type: dynamodb
  #         batchSize: 20
  #         startingPosition: TRIM_HORIZON
  #         arn:
  #           Fn::GetAtt:
  #             - EventsTable
  #             - StreamArn

  # triggered when an internal bot requests a message range (inbound messages)
  # inbox:
  #   handler: project/lib/lambda/inbox.handler
  #   memorySize: 1024
  #   events:
  #     - iot:
  #         sql: "SELECT * as data, topic() as topic FROM 'messages/get'"

  # triggered when a client requests a message range (outbound messages)
  # outbox:
  #   handler: project/lib/lambda/outbox.handler
  #   memorySize: 1024
  #   events:
  #     - iot:
  #         sql: "SELECT * as data, topic() as topic FROM '+/restore'"

  #   environment:
  #     DEBUG: tradle:*
  #   custom:
  #     env-resources:
  #       - ObjectsBucket
  #       - SecretsBucket
  #       - EventsTable
  #       - PresenceTable
  #       - PubKeysTable
  #       - InboxTable
  #       - OutboxTable
  #       - PublicConfBucket

  onconnect:
    handler: project/lib/lambda/mqtt/onconnect.handler
    events:
      - iot:
          sql: "SELECT * FROM '$aws/events/presence/connected/#'"
    environment:
      DEBUG: tradle:*
    custom:
      env-resources:
        - ObjectsBucket
        - SecretsBucket
        - EventsTable
        - PresenceTable
        - PubKeysTable
        - InboxTable
        - OutboxTable
        - SealsTable
        - PublicConfBucket

  ondisconnect:
    handler: project/lib/lambda/mqtt/ondisconnect.handler
    events:
      - iot:
          sql: "SELECT * FROM '$aws/events/presence/disconnected/#'"
    environment:
      DEBUG: tradle:*
    custom:
      env-resources:
        - ObjectsBucket
        - SecretsBucket
        - EventsTable
        - PresenceTable
        - PubKeysTable
        - InboxTable
        - OutboxTable
        - SealsTable
        - PublicConfBucket

  # triggered when a client subscribes to an MQTT topic
  onsubscribe:
    handler: project/lib/lambda/mqtt/onsubscribe.handler
    memorySize: 1024
    events:
      - iot:
          sql: "SELECT * FROM '$aws/events/subscriptions/subscribed/#'"
    environment:
      DEBUG: tradle:*
    custom:
      env-resources:
        - ObjectsBucket
        - SecretsBucket
        - EventsTable
        - PresenceTable
        - PubKeysTable
        - InboxTable
        - OutboxTable
        - SealsTable
        - PublicConfBucket

  # triggered when a client sends a message
  onmessage:
    handler: project/lib/lambda/mqtt/onmessage.handler
    memorySize: 1024
    environment:
      DEBUG: tradle:*
      BOT_LAMBDA: bot_onmessage
      SERVERLESS_PREFIX: ${{self:custom.prefix}}
      SERVERLESS_STAGE: ${{self:custom.stage}}
      SERVERLESS_SERVICE_NAME: ${{self:service}}
    events:
      - iot:
          sql: "SELECT * as data, clientid() as clientId FROM 'message'"
    custom:
      env-resources:
        - ObjectsBucket
        - SecretsBucket
        - EventsTable
        - PresenceTable
        - PubKeysTable
        - InboxTable
        - OutboxTable
        - SealsTable
        - PublicConfBucket

  # useful during development
  # trigger a message to be queued/sent
  send:
    handler: project/lib/lambda/send.handler
    memorySize: 1024
    custom:
      env-resources:
        - ObjectsBucket
        - SecretsBucket
        - EventsTable
        - PresenceTable
        - PubKeysTable
        - InboxTable
        - OutboxTable
        - SealsTable
        - PublicConfBucket

  # echo bot (business logic layer)
  bot_onmessage:
    handler: project/lib/lambda/samplebot/index.onmessage
    memorySize: 1024
    custom:
      env-resources:
        - ObjectsBucket
        - SecretsBucket
        - EventsTable
        - PresenceTable
        - PubKeysTable
        - InboxTable
        - OutboxTable
        - PublicConfBucket
    environment:
      DEBUG: tradle:*

  onsealevent:
    handler: project/lib/samplebot/index.onsealevent
    memorySize: 1024
    environment:
      DEBUG: tradle:*
    events:
      - stream:
          type: dynamodb
          batchSize: 1
          startingPosition: TRIM_HORIZON
          arn:
            Fn::GetAtt:
              - SealsTable
              - StreamArn

  # addcontact:
  #   handler: project/lib/lambda/add-contact.handler
  #   environment:
  #     DEBUG: tradle:*
  #   custom:
  #     env-resources:
  #       - ObjectsBucket
  #       - PubKeysTable

  identity:
    handler: project/lib/lambda/identity.handler
    environment:
      DEBUG: tradle:*
    custom:
      env-resources:
        - SecretsBucket
        - ObjectsBucket
        - PublicConfBucket
        - PubKeysTable

  # public endpoint for clients to get public configuration / provider identity
  info:
    handler: project/lib/lambda/info.handler
    environment:
      DEBUG: tradle:*
      SERVERLESS_STAGE: ${{self:custom.stage}}
      SERVERLESS_SERVICE_NAME: ${{self:service}}
    custom:
      env-resources:
        - PublicConfBucket
        - SecretsBucket
        - ObjectsBucket
        - PubKeysTable
    events:
      - http:
          path: tradle/info
          method: get
          cors: true

  # initialize provider identity
  init:
    handler: project/lib/lambda/init.handler
    memorySize: 512
    environment:
      BLOCKCHAIN: testnet
      DEBUG: tradle:*
    custom:
      env-resources:
        - SecretsBucket
        - ObjectsBucket
        - PubKeysTable
        - PublicConfBucket


  # Blockchain

  faucet_bitcoin:
    handler: project/lib/lambda/faucet-bitcoin.withdraw

  recharge:
    handler: project/lib/lambda/recharge.handler
    events:
      - schedule:
          rate: rate(10 minutes)
          enabled: false

  sealpending:
    handler: project/lib/lambda/sealpending.handler
    events:
      - schedule:
          rate: rate(10 minutes)
          enabled: true

  pollchain:
    handler: project/lib/lambda/pollchain.handler
    events:
      - schedule:
          rate: rate(10 minutes)
          enabled: true

    # environment:
    #   ENCRYPTION_KEY: ${{self:custom.secrets.SESSION_KEY}}
    #   EMAIL_SERVICE_API_KEY: ${{self:custom.secrets.EMAIL_SERVICE_API_KEY}}


resources:
  Resources:
    ObjectsBucket:
      Type: "AWS::S3::Bucket"
      Properties:
        BucketName: ${{self:custom.OBJECTS_BUCKET}}

    SecretsBucket:
      Type: "AWS::S3::Bucket"
      Properties:
        BucketName: ${{self:custom.SECRETS_BUCKET}}

    PrivateConfBucket:
      Type: "AWS::S3::Bucket"
      Properties:
        BucketName: ${{self:custom.PRIVATE_CONF_BUCKET}}

    PublicConfBucket:
      Type: "AWS::S3::Bucket"
      Properties:
        BucketName: ${{self:custom.PUBLIC_CONF_BUCKET}}
        AccessControl: PublicRead

    EventsTable: ${{file(./project/conf/table/events.yml)}}
    PubKeysTable: ${{file(./project/conf/table/pubkeys.yml)}}

    # stores metadata about incoming messages
    # bodies rot in s3
    InboxTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: InboxTable
        AttributeDefinitions:
          - AttributeName: ${{self:custom.props.author}}
            AttributeType: S
          # - AttributeName: ${{self:custom.props.seq}}
          #   AttributeType: N
          - AttributeName: ${{self:custom.props.link}}
            AttributeType: S
          - AttributeName: ${{self:custom.props.time}}
            AttributeType: N
        KeySchema:
          - AttributeName: ${{self:custom.props.author}}
            KeyType: HASH
          - AttributeName: ${{self:custom.props.time}}
            KeyType: RANGE
          # - AttributeName: ${{self:custom.props.seq}}
          #   KeyType: RANGE
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5
        StreamSpecification:
          StreamViewType: NEW_AND_OLD_IMAGES
        GlobalSecondaryIndexes:
          - IndexName: link
            KeySchema:
              - AttributeName: ${{self:custom.props.link}}
                KeyType: HASH
            Projection:
              ProjectionType: ALL
            ProvisionedThroughput:
              ReadCapacityUnits: 5
              WriteCapacityUnits: 5

    OutboxTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: OutboxTable
        AttributeDefinitions:
          - AttributeName: ${{self:custom.props.recipient}}
            AttributeType: S
          - AttributeName: ${{self:custom.props.time}}
            AttributeType: N
        KeySchema:
          - AttributeName: ${{self:custom.props.recipient}}
            KeyType: HASH
          - AttributeName: ${{self:custom.props.time}}
            KeyType: RANGE
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5
        StreamSpecification:
          StreamViewType: NEW_AND_OLD_IMAGES

    SealsTable: ${{file(./project/conf/table/seals.yml)}}


    # CursorTable:
    #   Type: AWS::DynamoDB::Table
    #   Properties:
    #     TableName: CursorTable
    #     AttributeDefinitions:
    #       - AttributeName: queue
    #         AttributeType: S
    #       - AttributeName: seq
    #         AttributeType: N
    #     KeySchema:
    #       - AttributeName: queue
    #         KeyType: HASH
    #       - AttributeName: seq
    #         KeyType: RANGE
    #     ProvisionedThroughput:
    #       ReadCapacityUnits: 5
    #       WriteCapacityUnits: 5
    #     StreamSpecification:
    #       StreamViewType: NEW_AND_OLD_IMAGES

    # WebhooksTable:
    #   Type: AWS::DynamoDB::Table
    #   Properties:
    #     TableName: WebhooksTable
    #     AttributeDefinitions:
    #       - AttributeName: event
    #         AttributeType: S
    #       - AttributeName: url
    #         AttributeType: N
    #     KeySchema:
    #       - AttributeName: event
    #         KeyType: HASH
    #       - AttributeName: url
    #         KeyType: RANGE
    #     ProvisionedThroughput:
    #       ReadCapacityUnits: 5
    #       WriteCapacityUnits: 5
    #     StreamSpecification:
    #       StreamViewType: NEW_AND_OLD_IMAGES

    # stores metadata about incoming messages
    # bodies rot in s3
    # MessagesTable:
    #   Type: AWS::DynamoDB::Table
    #   Properties:
    #     TableName: MessagesTable
    #     AttributeDefinitions:
    #       - AttributeName: ${{self:custom.props.author}}
    #         AttributeType: S
    #       - AttributeName: ${{self:custom.props.recipient}}
    #         AttributeType: S
    #       - AttributeName: ${{self:custom.props.seq}}
    #         AttributeType: N
    #     # Inbox
    #     KeySchema:
    #       - AttributeName: ${{self:custom.props.author}}
    #         KeyType: HASH
    #       - AttributeName: ${{self:custom.props.seq}}
    #         KeyType: RANGE
    #     ProvisionedThroughput:
    #       ReadCapacityUnits: 5
    #       WriteCapacityUnits: 5
    #     StreamSpecification:
    #       StreamViewType: NEW_AND_OLD_IMAGES
    #     # Outbox
    #     GlobalSecondaryIndexes:
    #       - IndexName: recipient
    #         KeySchema:
    #           - AttributeName: ${{self:custom.props.recipient}}
    #             KeyType: HASH
    #           - AttributeName: ${{self:custom.props.seq}}
    #             KeyType: RANGE
    #         Projection:
    #           ProjectionType: ALL
    #         ProvisionedThroughput:
    #           ReadCapacityUnits: 5
    #           WriteCapacityUnits: 5

    # stores mappings between identity permalink and ephemeral clientIds
    # mappings are created after initial handshake and destroyed on disconnect
    PresenceTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: PresenceTable
        AttributeDefinitions:
          - AttributeName: clientId
            AttributeType: S
          - AttributeName: permalink
            AttributeType: S
        KeySchema:
          - AttributeName: permalink
            KeyType: HASH
          - AttributeName: clientId
            KeyType: RANGE
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5

    # EventsStreamEventSourceMapping:
    #   Type: AWS::Lambda::EventSourceMapping
    #   DependsOn: IamPolicyLambdaExecution
    #   Properties:
    #     BatchSize: 10
    #     EventSourceArn:
    #       Fn::GetAtt:
    #         - EventsTable
    #         - StreamArn
    #     FunctionName:
    #       Fn::GetAtt:
    #         - fanout
    #         - Arn
    #     StartingPosition: TRIM_HORIZON
    #     Enabled: True



    # IoT
    # define IoT role
    # IoTLambdaRole:
    #   Type: AWS::IAM::Role
    #   Properties:
    #     AssumeRolePolicyDocument:
    #       Version: "2012-10-17"
    #       Statement:
    #         - Effect: Allow
    #           Principal:
    #             AWS: arn:aws:iam:::root
    #           Action:
    #             - sts:AssumeRole

    PushSubcribersTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: PushSubscribersTable
        AttributeDefinitions:
          - AttributeName: subscriber
            AttributeType: S
        KeySchema:
          - AttributeName: subscriber
            KeyType: HASH
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5

    IotClientRole:
      Type: AWS::IAM::Role
      Properties:
        RoleName: IotClientRole
        AssumeRolePolicyDocument:
          Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Principal:
                Service:
                  - lambda.amazonaws.com
                AWS:
                  - arn:aws:iam::${{self:custom.accountId}}:root
                  # - arn:aws:iam::${{self:custom.accountId}}:role/${{self:custom.prefix}}${{self:provider.region}}-lambdaRole"
                  # - Fn::Join" : [":", ["arn:aws:iam", { "Ref" : "AWS::Region" }, { "Ref" : "AWS::AccountId" }, "lambdaRole" ] ] }

                # AWS: "arn:aws:iam::${{}}:role/${{self:custom.prefix}}lambdaRole"
              Action:
                - sts:AssumeRole
        Policies:
          - PolicyName: IotClientRole
            PolicyDocument:
              Version: "2012-10-17"
              Statement:
                - Effect: Allow
                  Action:
                    - dynamodb:*
                  Resource:
                    - arn:aws:dynamodb:${{self:provider.region}}:${{self:custom.accountId}}:table/PresenceTable
                - Effect: Allow
                  Action:
                    - logs:CreateLogGroup
                    - logs:CreateLogStream
                    - logs:PutLogEvents
                  Resource: arn:aws:logs:::log-group:/aws/lambda/*:*:*
                # restrict client connect by client id
                - Effect: Allow
                  Action: ["iot:Connect"]
                  Resource: ["*"]
                  # Resource: ["aws:iot:::client/${iot:ClientId}/*"]
                # allow all clients to publish to the send topic
                - Effect: "Allow"
                  Action: ["iot:Publish"]
                  Resource: ["*"]
                  # Resource: [
                  #   "aws:iot:::topic/${iot:ClientId}/message",
                  #   "aws:iot:::topic/${iot:ClientId}/restore",
                  # ]
                # restrict client topic subscriptions by their client id
                - Effect: "Allow"
                  Action: ["iot:Subscribe"]
                  Resource: ["*"]
                  # Resource: ["aws:iot:::topicfilter/${iot:ClientId}/*"]
                # restrict messages clients receive by their client id
                # this has the same function as the Subscribe rule above
                # provided the Subscribe policy is upheld, this policy should always give a pass
                - Effect: "Allow"
                  Action: ["iot:Receive"]
                  Resource: ["*"]
                  # Resource: ["aws:iot:::topic/${iot:ClientId}/*"]

