service: ${{self:custom.service}}
frameworkVersion: ">=1.5.0 <2.0.0"

plugins:
  # - serverless-resources-env
  - serverless-plugin-tracing
  # - serverless-pseudo-parameters
  # - serverless-sam
  - serverless-apigw-binary
  - serverless-plugin-aws-alerts
  - serverless-plugin-common-excludes
  - serverless-dynamodb-autoscaling
  # - serverless-plugin-split-stacks
  # - serverless-plugin-warmup
  # - serverless-plugin-typescript
  - print
  - warmup
  # - serverless-dynamodb-ttl
  # - serverless-plugin-write-env-vars
  # - serverless-plugin-include-dependencies
  # - serverless-dynamodb-local
  - serverless-offline

package:
  # artifactDirectoryName: serverless/${{self:service}}/${{self:provider.stage}}/artifacts
  include:
    - conf
  exclude:
    - src
    - secrets.yml
    - vars.yml

custom:
  vars: ${{file(./vars.yml), file(./default-vars.yml)}}
  defaults: ${{file(./default-vars.yml)}}
  # move these to vars.yml when this issue is fixed:
  #   https://github.com/serverless/serverless/issues/3740
  service: ${{self:custom.vars.service, self:custom.defaults.service}}
  stage: ${{opt:stage, self:custom.vars.stage, self:custom.defaults.stage}}
  secrets: ${{file(./secrets.yml):${{self:custom.stage}}, self:custom.defaults.secrets}}
  # stage: dev
  region: ${{opt:region, self:custom.vars.region, self:custom.defaults.region}}
  profile: ${{opt:profile, self:custom.vars.profile, self:custom.defaults.profile}}
  versionFunctions: ${{self:custom.vars.versionFunctions, self:custom.defaults.versionFunctions}}
  blockchain: ${{self:custom.vars.blockchain, self:custom.defaults.blockchain}}
  providerConf: &providerConf
    ${{file(./src/samplebot/conf/provider.json)}}

  # copied from vars.yml
  # emailForNotifications: ${{self:custom.vars.emailForNotifications}}
  # blockchain: ${{self:custom.vars.blockchain}}
  thresholdBillingAlarm: ${{self:custom.vars.thresholdBillingAlarm, self:custom.defaults.thresholdBillingAlarm}}
  thresholdThrottlingAlarm: ${{self:custom.vars.thresholdThrottlingAlarm, self:custom.defaults.thresholdThrottlingAlarm}}
  thresholdErrorsAlarm: ${{self:custom.vars.thresholdErrorsAlarm, self:custom.defaults.thresholdErrorsAlarm}}
  thresholdInvocationsAlarm: ${{self:custom.vars.thresholdInvocationsAlarm, self:custom.defaults.thresholdInvocationsAlarm}}
  thresholdDurationAlarm: ${{self:custom.vars.thresholdDurationAlarm, self:custom.defaults.thresholdDurationAlarm}}

  # stage: ${{opt:stage, self:custom.vars.stage, self:custom.defaultStage}}
  # region: ${{opt:region, self:custom.vars.region}}

  # prefixes
  prefix: ${{self:service}}-${{self:custom.stage}}-
  prefixRole: ${{self:custom.prefix}}
  # maybe during info/auth, the server can send back the prefix
  # prefixIOTTopic: ${{self:service}}-
  iotParentTopic: ${{self:service}}-${{self:custom.stage}}
  prefixSNSTopic: ${{self:custom.prefix}}
  prefixSQS: ${{self:custom.prefix}}

  # versions
  versionSQL: "2016-03-23"
  emailForNotifications:
    ${{self:custom.vars.emailForNotifications, self:custom.defaults.emailForNotifications}}

  # sns
  # billingAlarmTopic: ${{self:custom.prefixSNSTopic}}BillingAlarmNotification
  # throttlingAlarmTopic: ${{self:custom.prefixSNSTopic}}ThrottlingAlarmNotification
  # invocationsAlarmTopic: ${{self:custom.prefixSNSTopic}}InvocationAlarmNotification
  # invocationErrorsAlarmTopic: ${{self:custom.prefixSNSTopic}}InvocationErrorsAlarmNotification

  alertNotifications:
    - protocol: email
      endpoint: ${{self:custom.emailForNotifications}}

  alerts:
    stages:
      - dev
    dashboards: true
    topics:
      # ok:
      #   topic: ${{self:custom.prefix}}alerts-ok
      #   notifications: ${{self:custom.alertNotifications}}
      alarm:
        topic: ${{self:custom.prefix}}alerts-alarm
        notifications: ${{self:custom.alertNotifications}}
      # insufficientData:
      #   topic: ${{self:custom.prefix}}alerts-insufficientData
      #   notifications: ${{self:custom.alertNotifications}}
    definitions:
      functionErrors:
        period: 60
        threshold: ${{self:custom.thresholdErrorsAlarm}}
      functionThrottles:
        period: 60
        threshold: ${{self:custom.thresholdThrottlingAlarm}}
      functionInvocations:
        period: 60
        threshold: ${{self:custom.thresholdInvocationsAlarm}}
      functionDuration:
        period: 60
        threshold: ${{self:custom.thresholdDurationAlarm}}
    alarms:
      # - functionErrors
      # - functionThrottles
      # - functionInvocations
      # - functionDuration

  # sqs
  deadLetterQueueName: ${{self:custom.prefixSQS}}dead-letter-queue

  # hostedZoneName: tradle.io
  # domainName: lambda1.tradle.io
  pushServer: https://push1.tradle.io

  tables:
    presence: ${{self:custom.prefix}}presence
    seals: ${{self:custom.prefix}}seals
    pubkeys: ${{self:custom.prefix}}pubkeys
    inbox: ${{self:custom.prefix}}inbox
    outbox: ${{self:custom.prefix}}outbox
    events: ${{self:custom.prefix}}events
    # pushsubscribers: ${{self:custom.prefix}}pushsubscribers
    users: ${{self:custom.prefix}}users
    friends: ${{self:custom.prefix}}friends
    conf: ${{self:custom.prefix}}conf
    kv: ${{self:custom.prefix}}kv

  # auto-scaled tables that serve as buckets for multiple models each
  defaultCapacity: &defaultCapacity
    read:
      minimum: 5        # Minimum read capacity
      maximum: 100      # Maximum read capacity
      usage: 0.70       # Targeted usage percentage
    write:
      minimum: 5        # Minimum write capacity
      maximum: 100      # Maximum write capacity
      usage: 0.5        # Targeted usage percentage

  tableBuckets:
    count: 4
    index:
      - _author
      - _t
    <<: *defaultCapacity

  capacities:
    - table: PubKeysTable
      index:
        - permalink
      <<: *defaultCapacity

    - table: InboxTable
      index:
        - _link
        - context
      <<: *defaultCapacity

    - table: OutboxTable
      index:
        - _payloadLink
        - context
      <<: *defaultCapacity

    - table: EventsTable
      write:
        minimum: 5        # Minimum write capacity
        maximum: 20       # Maximum write capacity
        usage: 0.5        # Targeted usage percentage

  apigwBinary:
    cors:
      origin: '*'
      headers:
        - Content-Type
        - X-Amz-Date
        - Authorization
        - X-Api-Key
        - X-Amz-Security-Token
        - X-Amz-User-Agent
        - X-Tradle-Sig
        - cache
      allowCredentials: false
    types:
      - '*/*'

  serverless-offline:
    mqttPort: ${{self:custom.vars.serverless-offline.mqttPort, self:custom.defaults.serverless-offline.mqttPort}}
    port: ${{self:custom.vars.serverless-offline.port, self:custom.defaults.serverless-offline.port}}

#   secrets: ${{file(secrets.${opt:stage, self:provider.stage}}.yml)}
  # dynamodb:
  #   start:
  #     port: 8000
  #     inMemory: true
  #     migration: true
  #   migration:
  #     dir: offline/migrations

provider:
  # avoid some bugs in serverless
  versionFunctions: ${{self:custom.versionFunctions}}
  tracing: true
  # https://github.com/serverless/serverless/issues/4312#issuecomment-331946882
  variableSyntax: "\\${{([ ~:a-zA-Z0-9._\\'\",\\-\\/\\(\\)]+?)}}"
  name: aws
  runtime: nodejs6.10
  profile: ${{self:custom.profile}}
  stage: ${{self:custom.stage}}
  region: ${{self:custom.region}}
  memorySize: 512
  timeout: 60
  # deploymentBucket: io.tradle.${{self:custom.stage}}.deploys
  environment:
    # enable long stack traces
    BLUEBIRD_DEBUG: 1
    # IOT_TOPIC_PREFIX: ${{self:custom.prefixIOTTopic}}
    IOT_PARENT_TOPIC: ${{self:custom.iotParentTopic}}
    # declare
    IOT_ENDPOINT: ''
    BLOCKCHAIN: ${{self:custom.blockchain}}
    DEBUG: 'Î»*,tradle:*,@tradle*'
    SERVERLESS_PREFIX: ${{self:custom.prefix}}
    SERVERLESS_STAGE: ${{self:custom.stage}}
    SERVERLESS_SERVICE_NAME: ${{self:service}}
    PUSH_SERVER_URL: ${{self:custom.pushServer}}
    NO_TIME_TRAVEL: false # allow time-travel messages for now

    # bot config
    # BOT_ONPRESENCE: ${{self:custom.bot_onpresence}}
    BOT_ONMESSAGE: bot_onmessage

    # API KEYS
    ONFIDO_API_KEY: ${{self:custom.secrets.ONFIDO_API_KEY, ''}}

  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:CreateTable
        - dynamodb:DescribeTable
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
        - dynamodb:BatchWriteItem
        - dynamodb:DescribeStream
        - dynamodb:GetRecords
        - dynamodb:GetShardIterator
        - dynamodb:ListStreams
      Resource:
        - Fn::Sub: 'arn:aws:dynamodb:${{self:custom.region}}:${AWS::AccountId}:table/${{self:custom.prefix}}*'
        # - Fn::Sub: 'arn:aws:dynamodb:${{self:custom.region}}:${AWS::AccountId}:table/${{self:custom.tables.events}}'
        # - Fn::Sub: 'arn:aws:dynamodb:${{self:custom.region}}:${AWS::AccountId}:table/${{self:custom.tables.presence}}'
        # - Fn::Sub: 'arn:aws:dynamodb:${{self:custom.region}}:${AWS::AccountId}:table/${{self:custom.tables.inbox}}'
        # - Fn::Sub: 'arn:aws:dynamodb:${{self:custom.region}}:${AWS::AccountId}:table/${{self:custom.tables.inbox}}/index/*'
        # - Fn::Sub: 'arn:aws:dynamodb:${{self:custom.region}}:${AWS::AccountId}:table/${{self:custom.tables.outbox}}'
        # - Fn::Sub: 'arn:aws:dynamodb:${{self:custom.region}}:${AWS::AccountId}:table/${{self:custom.tables.pubkeys}}'
        # - Fn::Sub: 'arn:aws:dynamodb:${{self:custom.region}}:${AWS::AccountId}:table/${{self:custom.tables.pubkeys}}/index/*'
        # - Fn::Sub: 'arn:aws:dynamodb:${{self:custom.region}}:${AWS::AccountId}:table/${{self:custom.tables.seals}}'
        # - Fn::Sub: 'arn:aws:dynamodb:${{self:custom.region}}:${AWS::AccountId}:table/${{self:custom.tables.seals}}/index/*'
        # # - Fn::Sub: 'arn:aws:dynamodb:${{self:custom.region}}:${AWS::AccountId}:table/${{self:custom.tables.pushsubscribers}}'
        # - Fn::Sub: 'arn:aws:dynamodb:${{self:custom.region}}:${AWS::AccountId}:table/${{self:custom.tables.users}}'
        # - Fn::Sub: 'arn:aws:dynamodb:${{self:custom.region}}:${AWS::AccountId}:table/${{self:custom.tables.users}}/index/*'

    # so lambdas can list resources in their stack
    - Effect: Allow
      Action:
        - cloudformation:ListStackResources
      Resource: ["*"]

    # allow lambdas to update themselves
    - Effect: Allow
      Action:
        - lambda:UpdateFunctionConfiguration
        - lambda:GetFunctionConfiguration
        - lambda:ListFunctions
      Resource:
        - Fn::Sub: 'arn:aws:lambda:${{self:custom.region}}:${AWS::AccountId}:function:${{self:custom.prefix}}*'

    # allow access to bucket
    # TODO: give access only to the lambdas that need it
    - Effect: Allow
      Action:
        # needed to get NoSuchKey error instead of AccessDenied for non-existent items
        # https://forums.aws.amazon.com/thread.jspa?threadID=56531
        - s3:ListBucket
      Resource:
        # - arn:aws:s3:::${{self:provider.deploymentBucket}}
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: PublicConfBucket
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: PrivateConfBucket
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: ContentAddressedBucket
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: ObjectsBucket
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: SecretsBucket
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: ServerlessDeploymentBucket
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: FileUploadBucket

    - Effect: Allow
      Action:
        - s3:PutObject
        # needed to create an object with public-read
        - s3:PutObjectAcl
        - s3:GetObject
        # needed to check existence
        - s3:HeadObject
      Resource:
        # - arn:aws:s3:::${{self:provider.deploymentBucket}}/*
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: PublicConfBucket
            - "/*"
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: PrivateConfBucket
            - "/*"
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: ContentAddressedBucket
            - "/*"
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: ObjectsBucket
            - "/*"
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: SecretsBucket
            - "/*"
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: ServerlessDeploymentBucket
            - "/*"
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: FileUploadBucket
            - "/*"

    # REMOVE in prod
    # allow access to buckets from the console
    - Effect: Allow
      Action:
        - s3:GetBucketLocation
        - s3:ListAllMyBuckets
      Resource: "arn:aws:s3:::*"

    # allow lambdas to call each other
    # TODO: make this more fine grained
    - Effect: Allow
      Action:
        - lambda:InvokeFunction
        - lambda:InvokeAsync
      Resource: "*"

    # Iot
    - Effect: Allow
      Action: ["iot:Connect", "iot:Subscribe", "iot:Publish", "iot:Receive", "iot:DescribeEndpoint"]
      Resource: ["*"]

    # gen Iot temp credentials (lambda: preauth)
    - Effect: Allow
      Action:
        - sts:AssumeRole
      Resource:
        - Fn::GetAtt:
          - IotClientRole
          - Arn
    - Effect: Allow
      Action:
        - xray:PutTraceSegments
        - xray:PutTelemetryRecords
      Resource: "*"
    - Effect: Allow
      Sid: AllowCloudFrontUpdateDistribution
      Action:
        - cloudfront:updateDistribution
      Resource: ["*"]

    # - Effect: Allow
    #   Action:
    #     - sqs:SendMessage
    #   # Resource: ["*"]
    #   Resource:
    #     - Fn::GetAtt:
    #       - DeadLetterQueue
    #       - Arn

      # Resource: "*"
   # - Effect: "Allow"
   #   Action:
   #     - "s3:GetObject"
   #   Resource: { "Fn::Join" : ["", ["arn:aws:s3:::", { "Ref" : "ServerlessDeploymentBucket" } ] ]  }
   # - Effect: "Allow"
   #   Action:
   #     - "s3:PutObject"
   #   Resource:
   #     Fn::Join:
   #       - ""
   #       - - "arn:aws:s3:::"
   #         - "Ref" : "ServerlessDeploymentBucket"
   #         - "/*"

functions:
  # warm up other functions
  warmup:
    handler: lib/lambda/warmup.handler
    memorySize: 128
    events:
      - schedule:
          rate: rate(5 minutes)
          enabled: true
          input:
            concurrency: 5
            functions:
              # - http_catchall
              - onconnect
              - ondisconnect
              - onsubscribe
              - onmessage
              - bot_onmessage
              - bot_graphql
              - bot_info
              - preauth
              - auth
              - inbox
              - onmessage_http
              - to-events:
                  concurrency: 2
              - bot_onmessagestream:
                  concurrency: 2
    alarms:
      - functionErrors
      # - functionThrottles
      # - functionInvocations

  # http router function
  # see various commented out http-event functions below
  # for details on what they do
  # http_catchall:
  #   memorySize: 1024
  #   handler: lib/lambda/http/default.handler
  #   events:
  #     - http:
  #         path: /
  #         method: ANY
  #     - http:
  #         # match all paths, the token 'any' doesn't mean anything special
  #         path: /{any+}
  #         method: ANY
  #   alarms:
  #     - functionErrors
  #     - functionThrottles
  #     - functionInvocations

  # 1. generates temporary credentials (STS) for new connections,
  #    and assumes IotClientRole on them
  # 2. creates an unauthenticated session,
  #    generates a challenge to be signed (verified in /auth)
  preauth:
    handler: lib/lambda/http/default.handler
    memorySize: 1024
    events:
      - http:
          path: preauth
          method: post

  # 1. validates the challenge response
  # 2. marks the session as authenticated
  auth:
    handler: lib/lambda/http/default.handler
    memorySize: 1024
    events:
      - http:
          path: auth
          method: post

  # createevent:
  #   handler: lib/lambda/createevent.handler
  #   memorySize: 512

  # replicates InboxTable to EventsTable
  to-events:
    handler: lib/lambda/replicate-to-events.handler
    memorySize: 256
    events:
      - stream:
          type: dynamodb
          batchSize: 100
          startingPosition: TRIM_HORIZON
          arn:
            Fn::GetAtt:
              - InboxTable
              - StreamArn
      - stream:
          type: dynamodb
          batchSize: 100
          startingPosition: TRIM_HORIZON
          arn:
            Fn::GetAtt:
              - OutboxTable
              - StreamArn
      - stream:
          type: dynamodb
          batchSize: 100
          startingPosition: TRIM_HORIZON
          arn:
            Fn::GetAtt:
              - SealsTable
              - StreamArn
    alarms:
      - functionErrors
      # - functionThrottles
      # - functionInvocations

  # log:
  #   handler: lib/lambda/log.handler
  #   # package:
  #   #   exclude:
  #   #     - node_modules/
  #   environment:
  #     DEBUG: tradle:*

    # events:
  #     - stream:
  #         type: dynamodb
  #         batchSize: 20
  #         startingPosition: TRIM_HORIZON
  #         arn:
  #           Fn::GetAtt:
  #             - EventsTable
  #             - StreamArn

  # POST messages here
  # log:
  #   handler: lib/lambda/http/default.handler
  #   memorySize: 1024
  #   events:
  #     - http:
  #         path: log
  #         method: any

  inbox:
    handler: lib/lambda/http/default.handler
    memorySize: 1024
    events:
      - http:
          path: inbox
          method: put
      - http:
          path: inbox
          method: post

  # triggered when an internal bot requests a message range (inbound messages)
  # inbox:
  #   handler: lib/lambda/inbox.handler
  #   memorySize: 1024
  #   events:
  #     - iot:
  #         sql: "SELECT * as data, topic() as topic FROM 'messages/get'"

  # triggered when a client requests a message range (outbound messages)
  # outbox:
  #   handler: lib/lambda/outbox.handler
  #   memorySize: 1024
  #   events:
  #     - iot:
  #         sql: "SELECT * as data, topic() as topic FROM '+/restore'"

  #   environment:
  #     DEBUG: tradle:*

  # handles IoT (MQTT) connections post-authentication
  # updates presence in PresenceTable
  onconnect:
    handler: lib/lambda/mqtt/onconnect.handler
    events:
      - iot:
          sql: "SELECT * FROM '$aws/events/presence/connected/#'"
          sqlVersion: ${{self:custom.versionSQL}}
    alarms:
      - functionErrors
      - functionThrottles
      - functionInvocations

  # updates presence in PresenceTable
  ondisconnect:
    handler: lib/lambda/mqtt/ondisconnect.handler
    events:
      - iot:
          sql: "SELECT * FROM '$aws/events/presence/disconnected/#'"
          sqlVersion: ${{self:custom.versionSQL}}
    alarms:
      - functionErrors
      - functionThrottles
      - functionInvocations

  # triggered when a client subscribes to an MQTT topic
  # sends the client any queued up messages
  onsubscribe:
    handler: lib/lambda/mqtt/onsubscribe.handler
    memorySize: 1024
    # give enough time to deliver backed-up message
    timeout: 60
    events:
      - iot:
          sql: "SELECT * FROM '$aws/events/subscriptions/subscribed/#'"
          sqlVersion: ${{self:custom.versionSQL}}
    alarms:
      - functionErrors
      - functionThrottles
      - functionInvocations

  # triggered when a client sends a message
  #
  # validates, stores in OutboxTable, in ObjectsBucker (for now),
  # and passes off to bot engine
  onmessage:
    handler: lib/lambda/mqtt/onmessage.handler
    memorySize: 1024
    #   BOT_ONMESSAGE: ${{self:custom.bot_onmessage}}
    #   SERVERLESS_PREFIX: ${{self:custom.prefix}}
    #   SERVERLESS_STAGE: ${{self:custom.stage}}
    #   SERVERLESS_SERVICE_NAME: ${{self:service}}
    events:
      - iot:
          sql: "SELECT * as data, clientid() as clientId, topic() as topic FROM '${{self:custom.iotParentTopic}}/+/pub/outbox'"
          sqlVersion: ${{self:custom.versionSQL}}
    alarms:
      - functionErrors
      - functionThrottles
      - functionInvocations

  # same as onmessage, but can handle larger payloads
  # MQTT is limited to 128KB, HTTP to 6MB
  onmessage_http:
    handler: lib/lambda/http/default.handler
    memorySize: 1024
    events:
      - http:
          path: message
          method: put
      - http:
          path: message
          method: post
    alarms:
      - functionErrors
      - functionThrottles
      - functionInvocations

  # useful during development
  # trigger a message to be queued/sent to a user
  send:
    handler: lib/lambda/send.handler
    memorySize: 256

  # addcontact:
  #   handler: lib/lambda/add-contact.handler
  #   environment:
  #     DEBUG: tradle:*

  addfriend:
    handler: lib/lambda/add-friend.handler
    memorySize: 256

  addfriend_dev:
    handler: lib/lambda/http/default.handler
    # dev mode only
    events:
      - http:
          path: /addfriend
          method: post


  # performs service discovery - builds a map of logical->physical ids
  # and writes that map to the environment variables of all other lambdas
  # setenvvars:
  #   handler: lib/lambda/setenvvars.handler
  #   # hack to enable discovery own function's own stack
  #   description:
  #     Ref: AWS::StackId

  # initializes provider identity
  # generates a new identity and keys, and other misc crap
  # init:
  #   handler: lib/lambda/init.handler
  #   memorySize: 256
  #   timeout: 300
  #   alarms:
  #     - functionErrors
  #     - functionThrottles
  #     - functionInvocations

  # setstyle:
  #   handler: lib/lambda/setstyle.handler
  #   memorySize: 128
  #   alarms:
  #     - functionErrors
  #     - functionThrottles
  #     - functionInvocations

  # precreate-tables:
  #   handler: lib/lambda/precreate-tables.handler
  #   memorySize: 128
  #   timeout: 300

  # Blockchain

  # bitcoin faucet (surprise!)
  # distributes testnet coins from local funds
  # faucet_bitcoin:
  #   handler: lib/lambda/faucet-bitcoin.withdraw

  # gets funds from a bitcoin testnet faucet
  # recharge_bitcoin:
  #   handler: lib/lambda/recharge-bitcoin.handler
  #   events:
  #     - schedule:
  #         rate: rate(10 minutes)
  #         enabled: false

  # get funds from ethereum testnet faucet
  # (doesn't work on rinkeby, and doesn't work well on ropsten)
  # recharge_ethereum:
  #   handler: lib/lambda/recharge-ethereum.handler
  #   events:
  #     - schedule:
  #         rate: rate(10 minutes)
  #         enabled: false

  # writes pending transactions to the blockchain
  sealpending:
    handler: lib/lambda/sealpending.handler
    memorySize: 256
    timeout: 60
    events:
      - schedule:
          rate: rate(10 minutes)
          # enabled: false
    alarms:
      - functionErrors
      # - functionThrottles
      # - functionInvocations

  # polls the status of unconfirmed blockchain transactions
  pollchain:
    handler: lib/lambda/pollchain.handler
    memorySize: 256
    timeout: 60
    events:
      - schedule:
          rate: rate(10 minutes)
          # enabled: false
    alarms:
      - functionErrors
      # - functionThrottles
      # - functionInvocations

    # environment:
    #   ENCRYPTION_KEY: ${{self:custom.secrets.SESSION_KEY}}
    #   EMAIL_SERVICE_API_KEY: ${{self:custom.secrets.EMAIL_SERVICE_API_KEY}}

  checkFailedSeals:
    handler: lib/lambda/check-failed-seals.handler
    memorySize: 256
    timeout: 60
    events:
      - schedule:
          rate: rate(17 minutes)
          # enabled: false
    alarms:
      - functionErrors

  bot_oninit:
    handler: lib/samplebot/lambda/init.handler
    memorySize: 1024

  bot_info:
    handler: lib/samplebot/lambda/http/info.handler
    memorySize: 256
    events:
      - http:
          path: info
          method: get

  bot_onmessage:
    handler: lib/samplebot/index.onmessage
    memorySize: 1024
    alarms:
      - functionErrors
      - functionThrottles
      - functionInvocations

  bot_onsealevent:
    handler: lib/samplebot/index.onseal
    memorySize: 256
    events:
      - stream:
          type: dynamodb
          batchSize: 1
          startingPosition: TRIM_HORIZON
          arn:
            Fn::GetAtt:
              - SealsTable
              - StreamArn
    alarms:
    - functionErrors

  bot_onmessagestream:
    handler: lib/samplebot/index.onmessagestream
    memorySize: 256
    events:
      - stream:
          type: dynamodb
          batchSize: 100
          startingPosition: TRIM_HORIZON
          arn:
            Fn::GetAtt:
              - InboxTable
              - StreamArn
      - stream:
          type: dynamodb
          batchSize: 100
          startingPosition: TRIM_HORIZON
          arn:
            Fn::GetAtt:
              - OutboxTable
              - StreamArn
    alarms:
      - functionErrors
      # - functionThrottles
      # - functionInvocations
    # onError:
      # Ref: DeadLetterQueue

  bot_graphql:
    # make sure graphql route gets loaded
    handler: lib/samplebot/lambda/http/graphql.handler
    # handler: lib/lambda/http/default.handler
    memorySize: 512
    events:
      - http:
          path: graphql
          method: get
      - http:
          path: graphql
          method: post
    alarms:
      - functionErrors
      - functionThrottles
      - functionInvocations

  bot_setstyle:
    handler: lib/samplebot/lambda/set-style.handler
    memorySize: 128

  # bot-serviced lambda
  # generates sample data for browsing with GraphQL
  bot_samples:
    handler: lib/samplebot/index.onsamples
    # handler: lib/lambda/http/default.handler
    memorySize: 1024

  bot_samples_dev:
    handler: lib/samplebot/index.onsamples
    # handler: lib/lambda/http/default.handler
    memorySize: 1024
    events:
      - http:
          path: samples
          method: post

  bot_onfido:
    handler: lib/samplebot/lambda/http/onfido-webhook.handler
    # handler: lib/lambda/http/default.handler
    memorySize: 1024
    events:
      - http:
          path: onfido
          method: post

resources:
  Resources:
    # servless-framework-generated API Gateway
    # ApiGatewayStage:
    #   Type: AWS::ApiGateway::Stage
    #   Properties:
    #     MethodSettings:
    #       - DataTraceEnabled: true
    #         HttpMethod: "*"
    #         LoggingLevel: INFO
    #         ResourcePath: "/*"
    #         MetricsEnabled: true

    # content-addressed storage
    # stores message payloads (message minus envelope)
    # may be going away soon
    ObjectsBucket:
      Type: "AWS::S3::Bucket"
      Description: content-addressed storage for all objects
      DeletionPolicy: Retain

    # stores identity keys
    SecretsBucket:
      Type: "AWS::S3::Bucket"
      Description: stuff
      DeletionPolicy: Retain

    PrivateConfBucket:
      Type: "AWS::S3::Bucket"
      Description: private configuration files
      DeletionPolicy: Retain

    # stores the provider's public config
    # e.g. styles, currency, etc.
    PublicConfBucket:
      Type: "AWS::S3::Bucket"
      Description: public configuration, e.g. identity, styles, logo, etc.
      DeletionPolicy: Retain
      # Properties:
      #   AccessControl: PublicRead

    ContentAddressedBucket:
      Type: "AWS::S3::Bucket"
      Description: content-addressed storage
      DeletionPolicy: Retain

    # stores media uploaded by users
    FileUploadBucket:
      Type: "AWS::S3::Bucket"
      Description: file upload destination for all users
      DeletionPolicy: Retain
      Properties:
        CorsConfiguration:
          CorsRules:
            - AllowedMethods:
                - GET
                - PUT
                - POST
              AllowedOrigins:
                - "*"
              AllowedHeaders:
                - "*"
              MaxAge: 3600

    FileUploadBucketPolicy:
      Type: AWS::S3::BucketPolicy
      Properties:
        Bucket:
          Ref: FileUploadBucket
        PolicyDocument:
          Id: FileUploadBucketPolicy
          Version: '2012-10-17'
          Statement:
          - Sid: PutAccess
            Action:
            - s3:PutObject
            Effect: Allow
            Resource:
              - Fn::Join:
                - ""
                - - "arn:aws:s3:::"
                  - Ref: FileUploadBucket
                  - /
                  # ${aws:userid} will change on every session
                  # which will prevent users from clobbering old uploads
                  - ${aws:userid}
                  - "/*"
            Principal:
              AWS:
                Fn::GetAtt:
                  - IotClientRole
                  - Arn

    # EventsTable: ${{file(./conf/table/events.yml)}}

    # master log from which things can be rebuilt
    # in case of schema changes, disasters, etc.
    EventsTable:
      Type: AWS::DynamoDB::Table
      Description: source of truth
      Properties:
        TableName: ${{self:custom.tables.events}}
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5
        StreamSpecification:
          StreamViewType: NEW_IMAGE

    # PubKeysTable: ${{file(./conf/table/pubkeys.yml)}}

    # address book
    # maps public keys to identities that control them
    PubKeysTable:
      Type: AWS::DynamoDB::Table
      Description: maps pub keys to identities
      Properties:
        TableName: ${{self:custom.tables.pubkeys}}
        AttributeDefinitions:
          - AttributeName: pub
            AttributeType: S
          - AttributeName: permalink
            AttributeType: S
        KeySchema:
          - AttributeName: pub
            KeyType: HASH
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5
        GlobalSecondaryIndexes:
          - IndexName: permalink
            KeySchema:
              - AttributeName: permalink
                KeyType: HASH
            Projection:
              ProjectionType: INCLUDE
              NonKeyAttributes:
                - link
            ProvisionedThroughput:
              ReadCapacityUnits: 5
              WriteCapacityUnits: 5

    # bodies rot in s3
    # InboxTable: ${{file(./conf/table/inbox.yml)}}

    # stores received messages (minus their payloads)
    InboxTable:
      Type: AWS::DynamoDB::Table
      Description: inbound messages from users
      Properties:
        TableName: ${{self:custom.tables.inbox}}
        AttributeDefinitions:
          - AttributeName: _author
            AttributeType: S
          # - AttributeName: ${{self:custom.props.seq}}
          #   AttributeType: N
          - AttributeName: time
            AttributeType: N
          - AttributeName: _link
            AttributeType: S
          - AttributeName: context
            AttributeType: S
        KeySchema:
          - AttributeName: _author
            KeyType: HASH
          - AttributeName: time
            KeyType: RANGE
          # - AttributeName: seq
          #   KeyType: RANGE
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5
        StreamSpecification:
          StreamViewType: NEW_AND_OLD_IMAGES
        GlobalSecondaryIndexes:
          - IndexName: _link
            KeySchema:
              - AttributeName: _link
                KeyType: HASH
            Projection:
              ProjectionType: ALL
            ProvisionedThroughput:
              ReadCapacityUnits: 5
              WriteCapacityUnits: 5
          - IndexName: context
            KeySchema:
              - AttributeName: context
                KeyType: HASH
              - AttributeName: time
                KeyType: RANGE
            Projection:
              ProjectionType: KEYS_ONLY
            ProvisionedThroughput:
              ReadCapacityUnits: 5
              WriteCapacityUnits: 5

    # OutboxTable: ${{file(./conf/table/outbox.yml)}}

    # stores received messages (minus their payloads)
    OutboxTable:
      Type: AWS::DynamoDB::Table
      Description: outbound messages to users
      Properties:
        TableName: ${{self:custom.tables.outbox}}
        AttributeDefinitions:
          - AttributeName: _recipient
            AttributeType: S
          - AttributeName: time
            AttributeType: N
          - AttributeName: _payloadLink
            AttributeType: S
          - AttributeName: context
            AttributeType: S
        KeySchema:
          - AttributeName: _recipient
            KeyType: HASH
          - AttributeName: time
            KeyType: RANGE
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5
        StreamSpecification:
          StreamViewType: NEW_AND_OLD_IMAGES
        GlobalSecondaryIndexes:
          - IndexName: _payloadLink
            KeySchema:
              - AttributeName: _payloadLink
                KeyType: HASH
            Projection:
              ProjectionType: KEYS_ONLY
            ProvisionedThroughput:
              ReadCapacityUnits: 5
              WriteCapacityUnits: 5
          - IndexName: context
            KeySchema:
              - AttributeName: context
                KeyType: HASH
              - AttributeName: time
                KeyType: RANGE
            Projection:
              ProjectionType: KEYS_ONLY
            ProvisionedThroughput:
              ReadCapacityUnits: 5
              WriteCapacityUnits: 5

    # SealsTable: ${{file(./conf/table/seals.yml)}}

    # stores pending and confirmed seals
    # i.e. object links and corresponding blockchain transaction links
    SealsTable:
      Type: AWS::DynamoDB::Table
      Description: blockchain seals for objects
      Properties:
        TableName: ${{self:custom.tables.seals}}
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
          - AttributeName: address
            AttributeType: S
          # 'y' vs null
          - AttributeName: unconfirmed
            AttributeType: S
          - AttributeName: unsealed
            AttributeType: S
          - AttributeName: link
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5
        StreamSpecification:
          StreamViewType: NEW_AND_OLD_IMAGES
        GlobalSecondaryIndexes:
          - IndexName: unconfirmed
            KeySchema:
              - AttributeName: unconfirmed
                KeyType: HASH
              - AttributeName: address
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
            ProvisionedThroughput:
              ReadCapacityUnits: 5
              WriteCapacityUnits: 5
          - IndexName: unsealed
            KeySchema:
              - AttributeName: unsealed
                KeyType: HASH
              - AttributeName: address
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
            ProvisionedThroughput:
              ReadCapacityUnits: 5
              WriteCapacityUnits: 5
          - IndexName: link
            KeySchema:
              - AttributeName: link
                KeyType: HASH
            Projection:
              ProjectionType: KEYS_ONLY
            ProvisionedThroughput:
              ReadCapacityUnits: 5
              WriteCapacityUnits: 5

    # UsersTable: ${{file(./conf/table/users.yml)}}

    # used by the bot
    # stores schema-free user state objects
    UsersTable:
      Type: AWS::DynamoDB::Table
      Description: per-user state objects
      Properties:
        TableName: ${{self:custom.tables.users}}
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5

    # stores mappings between identity permalinks and ephemeral clientIds
    # mappings are created after initial handshake and destroyed on disconnect
    PresenceTable:
      Type: AWS::DynamoDB::Table
      Description: maps ephemeral mqtt client ids to identity permalinks
      Properties:
        TableName: ${{self:custom.tables.presence}}
        AttributeDefinitions:
          - AttributeName: clientId
            AttributeType: S
          - AttributeName: permalink
            AttributeType: S
        KeySchema:
          - AttributeName: permalink
            KeyType: HASH
          - AttributeName: clientId
            KeyType: RANGE
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5

    FriendsTable:
      Type: AWS::DynamoDB::Table
      Description: store friends (other providers)
      Properties:
        TableName: ${{self:custom.tables.friends}}
        AttributeDefinitions:
          # - AttributeName: url
          #   AttributeType: S
          - AttributeName: _identityPermalink
            AttributeType: S
        KeySchema:
          - AttributeName: _identityPermalink
            KeyType: HASH
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5

    KVTable:
      Type: AWS::DynamoDB::Table
      Description: freeform key-value store
      Properties:
        TableName: ${{self:custom.tables.kv}}
        AttributeDefinitions:
          - AttributeName: key
            AttributeType: S
        KeySchema:
          - AttributeName: key
            KeyType: HASH
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5

    ConfTable:
      Type: AWS::DynamoDB::Table
      Description: freeform configuration values
      Properties:
        TableName: ${{self:custom.tables.conf}}
        AttributeDefinitions:
          - AttributeName: key
            AttributeType: S
        KeySchema:
          - AttributeName: key
            KeyType: HASH
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5

    # PushSubcribersTable:
    #   Type: AWS::DynamoDB::Table
    #   Properties:
    #     TableName: ${{self:custom.tables.pushsubscribers}}
    #     AttributeDefinitions:
    #       - AttributeName: subscriber
    #         AttributeType: S
    #     KeySchema:
    #       - AttributeName: subscriber
    #         KeyType: HASH
    #     ProvisionedThroughput:
    #       ReadCapacityUnits: 5
    #       WriteCapacityUnits: 5

    # role assumed by all IoT clients
    IotClientRole:
      Type: AWS::IAM::Role
      Description: role assumed by every connecting client
      Properties:
        RoleName: ${{self:custom.prefixRole}}IotClientRole
        AssumeRolePolicyDocument:
          Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Principal:
                Service:
                  - lambda.amazonaws.com
                AWS:
                  - Fn::Sub: 'arn:aws:iam::${AWS::AccountId}:root'
                  # would be nice to use the below Fn::GetAtt
                  # but it creates a circular dep
                  # - Fn::Sub: 'arn:aws:iam::${AWS::AccountId}:role/${{self:custom.prefix}}${{self:provider.region}}-lambdaRole'
                  # - Fn::GetAtt:
                  #   - IamRoleLambdaExecution
                  #   - Arn
              Action:
                - sts:AssumeRole
        Policies:
          - PolicyName: IotClientRole
            PolicyDocument:
              Version: "2012-10-17"
              Statement:
                - Effect: Allow
                  Action:
                    - dynamodb:*
                  Resource:
                    - Fn::Sub: 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/PresenceTable'
                - Effect: Allow
                  Action:
                    - logs:CreateLogGroup
                    - logs:CreateLogStream
                    - logs:PutLogEvents
                  Resource: arn:aws:logs:::log-group:/aws/lambda/*:*:*
                # restrict client connect by client id
                - Effect: Allow
                  Action: ["iot:Connect"]
                  # Resource: ["*"]
                  Resource:
                    - Fn::Join:
                      - ":"
                      - - 'arn:aws:iot'
                        - Ref: AWS::Region
                        - Ref: AWS::AccountId
                        - 'client/${iot:ClientId}'

                # allow all clients to publish to the send topic
                - Effect: "Allow"
                  Action: ["iot:Publish"]
                  # Resource: ["*"]
                  Resource:
                    - Fn::Join:
                      - ":"
                      - - 'arn:aws:iot'
                        - Ref: AWS::Region
                        - Ref: AWS::AccountId
                        - 'topic/${{self:custom.iotParentTopic}}/${iot:ClientId}/pub/outbox'
                  #   - arn:aws:iot:::topic/${{self:custom.prefixIOTTopic}}message
                  #   - arn:aws:iot:::topic/${{self:custom.prefixIOTTopic}}restore

                # restrict client topic subscriptions by their client id
                - Effect: "Allow"
                  Action: ["iot:Subscribe"]
                  # Resource: ["*"]
                  Resource:
                    - Fn::Join:
                      - ":"
                      - - 'arn:aws:iot'
                        - Ref: AWS::Region
                        - Ref: AWS::AccountId
                        - 'topicfilter/${{self:custom.iotParentTopic}}/${iot:ClientId}/sub/*'
                # restrict messages clients receive by their client id
                # this has the same function as the Subscribe rule above
                # provided the Subscribe policy is upheld, this policy should always give a pass
                - Effect: "Allow"
                  Action: ["iot:Receive"]
                  Resource:
                    - Fn::Join:
                      - ":"
                      - - 'arn:aws:iot'
                        - Ref: AWS::Region
                        - Ref: AWS::AccountId
                        - 'topic/${{self:custom.iotParentTopic}}/${iot:ClientId}/sub/*'

    Initialize:
      Type: "Custom::InitializeDeployment"
      Properties:
        ServiceToken:
          Fn::GetAtt: [BotUnderscoreoninitLambdaFunction, Arn]
        ProviderConf:
          <<: *providerConf

        # CodeDeployApplicationName: !Ref "CodeDeployApplication"
        # CodeDeployDeploymentGroupName: !Ref "CodeDeployDeploymentGroup"
        # LoadBalancerName: !Ref "ElasticLoadBalancingLoadBalancer"
        # ResourceProperties:

    # primarily for autoscaling dynamodb
    # AutoScalingRole:
    #   Type: AWS::IAM::Role
    #   Description: role for autoscaling resources
    #   Properties:
    #     RoleName: ${{self:custom.prefixRole}}AutoScalingRole
    #     AssumeRolePolicyDocument:
    #       Version: "2012-10-17"
    #       Statement:
    #         - Effect: Allow
    #           Principal:
    #             Service:
    #               - application-autoscaling.amazonaws.com
    #           Action:
    #             - sts:AssumeRole
    #     Policies:
    #       - PolicyName: AutoScalingPolicy
    #         PolicyDocument:
    #           Version: "2012-10-17"
    #           Statement:
    #             - Effect: Allow
    #               Action:
    #                 - dynamodb:DescribeTable
    #                 - dynamodb:UpdateTable
    #                 - cloudwatch:DescribeAlarms
    #                 - cloudwatch:DeleteAlarms
    #                 - cloudwatch:PutMetricAlarm
    #                 - cloudwatch:GetMetricStatistics
    #                 - cloudwatch:SetAlarmState
    #               Resource:
    #                 - "*"

    # ReadCapacityScalableTarget:
    #   Type: "AWS::ApplicationAutoScaling::ScalableTarget"
    #   Properties:
    #     MaxCapacity: 10
    #     MinCapacity: 5
    #     ResourceId: !Join
    #       - /
    #       - - table
    #         - !Ref DDBTable
    #     RoleARN: !GetAtt AutoScalingRole.Arn
    #     ScalableDimension: dynamodb:table:ReadCapacityUnits
    #     ServiceNamespace: dynamo

    # WriteCapacityScalableTarget:
    #   Type: "AWS::ApplicationAutoScaling::ScalableTarget"
    #   Properties:
    #     MaxCapacity: 10
    #     MinCapacity: 5
    #     ResourceId: !Join
    #       - /
    #       - - table
    #         - !Ref DDBTable
    #     RoleARN: !GetAtt AutoScalingRole.Arn
    #     ScalableDimension: dynamodb:table:WriteCapacityUnits
    #     ServiceNamespace: dynamodb

    # WriteScalingPolicy:
    #   Type: "AWS::ApplicationAutoScaling::ScalingPolicy"
    #   Properties:
    #     PolicyName: WriteAutoScalingPolicy
    #     PolicyType: TargetTrackingScaling
    #     ScalingTargetId: !Ref WriteCapacityScalableTarget
    #     TargetTrackingScalingPolicyConfiguration:
    #       TargetValue: 50.0
    #       ScaleInCooldown: 60
    #       ScaleOutCooldown: 60
    #       PredefinedMetricSpecification:
    #         PredefinedMetricType: DynamoDBWriteCapacityUtilization

    # WriteAutoscalingPolicy:
    #   Type: AWS::ApplicationAutoScaling::ScalingPolicy
    #   Properties:
    #     PolicyName: WriteAutoScalingPolicy
    #     PolicyType: TargetTrackingScaling
    #     TargetTrackingScalingPolicyConfiguration:
    #       TargetValue: 50.0,
    #       ScaleInCooldown: 60
    #       ScaleOutCooldown: 60
    #       PredefinedMetricSpecification:
    #         PredefinedMetricType: DynamoDBWriteCapacityUtilization

    # ReadAutoscalingPolicy:
    #   Type: AWS::ApplicationAutoScaling::ScalingPolicy
    #   Properties:
    #     PolicyName: ReadAutoScalingPolicy
    #     PolicyType: TargetTrackingScaling
    #     TargetTrackingScalingPolicyConfiguration:
    #       TargetValue: 50.0,
    #       ScaleInCooldown: 60
    #       ScaleOutCooldown: 60
    #       PredefinedMetricSpecification:
    #         PredefinedMetricType: DynamoDBWriteCapacityUtilization

    # Alarms

    # BillingAlarmNotification:
    #   Type: AWS::SNS::Topic
    #   Properties:
    #     TopicName: ${{self:custom.billingAlarmTopic}}

    # first enable Billing Alerts
    #
    # http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/monitor-charges.html
    # BillingAlarm:
    #   Type: AWS::CloudWatch::Alarm
    #   Properties:
    #     AlarmDescription: Alarm if AWS spending is over ${{self:custom.thresholdBillingAlarm}}
    #     Namespace: AWS/Billing
    #     MetricName: EstimatedCharges
    #     Dimensions:
    #       - Name: Currency
    #         Value: USD
    #     Statistic: Maximum
    #     Period: '21600'
    #     Unit: Seconds
    #     EvaluationPeriods: '1'
    #     Threshold: ${{self:custom.thresholdBillingAlarm}}
    #     TreatMissingData: missing
    #     ComparisonOperator: GreaterThanThreshold
    #     AlarmActions:
    #       - Ref: BillingAlarmNotification
    #    # InsufficientDataActions:
    #    #   - Ref: BillingAlarmNotification

    # ThrottlingAlarmNotification:
    #   Type: AWS::SNS::Topic
    #   Properties:
    #     TopicName: ${{self:custom.throttlingAlarmTopic}}
    #     Subscription:
    #       - Endpoint: ${{self:custom.emailForNotifications}}
    #         Protocol: email

    # ThrottlingAlarm:
    #   Type: AWS::CloudWatch::Alarm
    #   Properties:
    #     AlarmDescription: Alarm if a lambda function is throttled
    #     Namespace: AWS/Lambda
    #     MetricName: Throttles
    #     Statistic: Sum
    #     Period: '60'
    #     Unit: Seconds
    #     EvaluationPeriods: '1'
    #     Threshold: ${{self:custom.thresholdThrottlingAlarm}}
    #     TreatMissingData: missing
    #     ComparisonOperator: GreaterThanThreshold
    #     AlarmActions:
    #       - Ref: ThrottlingAlarmNotification
    #     # InsufficientDataActions:
    #     #   - Ref: ThrottlingAlarmNotification

    # InvocationAlarmNotification:
    #   Type: AWS::SNS::Topic
    #   Properties:
    #     TopicName: ${{self:custom.invocationsAlarmTopic}}
    #     Subscription:
    #       - Endpoint: ${{self:custom.emailForNotifications}}
    #         Protocol: email

    # InvocationAlarm:
    #   Type: AWS::CloudWatch::Alarm
    #   Properties:
    #     AlarmDescription: Alarm if there suspiciously many lambda invocations
    #     Namespace: AWS/Lambda
    #     MetricName: Invocations
    #     Statistic: Sum
    #     Period: '60'
    #     Unit: Seconds
    #     EvaluationPeriods: '1'
    #     Threshold: ${{self:custom.thresholdInvocationsAlarm}}
    #     TreatMissingData: missing
    #     ComparisonOperator: GreaterThanThreshold
    #     AlarmActions:
    #       - Ref: InvocationAlarmNotification
    #     # InsufficientDataActions:
    #     #   - Ref: InvocationAlarmNotification

    # InvocationErrorAlarmNotification:
    #   Type: AWS::SNS::Topic
    #   Properties:
    #     TopicName: ${{self:custom.invocationErrorsAlarmTopic}}
    #     Subscription:
    #       - Endpoint: ${{self:custom.emailForNotifications}}
    #         Protocol: email

    # InvocationErrorAlarm:
    #   Type: AWS::CloudWatch::Alarm
    #   Properties:
    #     AlarmDescription: Alarm if a lambda functions throw errors
    #     Namespace: AWS/Lambda
    #     MetricName: Errors
    #     Statistic: Sum
    #     Period: '60'
    #     Unit: Seconds
    #     EvaluationPeriods: '1'
    #     Threshold: ${{self:custom.thresholdErrorsAlarm}}
    #     TreatMissingData: missing
    #     ComparisonOperator: GreaterThanThreshold
    #     AlarmActions:
    #       - Ref: InvocationErrorAlarmNotification
    #     # InsufficientDataActions:
    #     #   - Ref: InvocationErrorAlarmNotification

    # DeadLetterQueue:
    #   Type: AWS::SQS::Queue

    # SSLCertificate:
    #   Type: "AWS::CloudFormation::Stack"
    #   Properties:
    #     Parameters:
    #       domain: ${{file(./parameters.json):DomainName.Default}}
    #       hostedZoneName: ${{file(./parameters.json):HostedZoneName.Default}}
    #     TemplateURL: "https://s3-eu-west-1.amazonaws.com/is24-infrastructure-public/cloudformation/verified-ssl-certificate/ssl-certificate.template.yaml"

    # Type: AWS::Route53::RecordSet
    # Properties:
    #   HostedZoneName: ${{self:custom.hostedZoneName}}
    #   Comment: Tradle public API endpoint subdomain
    #   Name:  !Join ['', [!Ref 'Ec2Instance', ., !Ref 'AWS::Region', ., !Ref 'HostedZone', .]]
    #   Type: CNAME
    #   ResourceRecords:
    #   - Fn::GetAtt: Ec2Instance.PublicIp

    # PathMapping:
    #   Type: AWS::ApiGateway::BasePathMapping
    #   # DependsOn: ApiGatewayRestApi
    #   Properties:
    #     BasePath: ${{self:custom.stage}}
    #     DomainName: ${{self:custom.domainName}}
    #     RestApiId:
    #       Ref: ApiGatewayRestApi
    #     Stage: ${{self:custom.stage}}
