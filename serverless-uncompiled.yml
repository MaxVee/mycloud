service: ${{self:custom.service}}
frameworkVersion: ">=1.5.0 <2.0.0"

plugins:
  - prepare-offline
  # - serverless-resources-env
  - serverless-plugin-tracing
  # - serverless-pseudo-parameters
  # - serverless-sam
  # - serverless-apigw-binary
  - serverless-plugin-aws-alerts
  # - serverless-plugin-common-excludes
  - serverless-plugin-log-retention
  - serverless-dynamodb-autoscaling
  # - serverless-s3-encryption
  # - serverless-plugin-split-stacks
  # - serverless-plugin-warmup
  # - serverless-plugin-typescript
  # - print
  - warmup
  # - serverless-dynamodb-ttl
  # - serverless-plugin-write-env-vars
  # - serverless-plugin-include-dependencies
  # - serverless-dynamodb-local
  - serverless-dynamodb-local
  - serverless-s3-local
  - serverless-iot-local
  - init-local
  - serverless-offline
  # - serverless-offline-scheduler

package:
  # artifactDirectoryName: serverless/${{self:service}}/${{self:provider.stage}}/artifacts
  include:
    - conf
    - serverless-interpolated.yml
  exclude:
    - src/**
    - secrets.yml
    - vars.yml
    - logs/**
    - "*.log"
    - "*.rdb"
    - ".*"
    - loadtesting/**
    - myswagger.json
    - myidentity.json
    - lib/test/**
    - lib/scripts/**
    - conf/**
    - certs/**
    - org/**
    - docker/**
    - docs/**
    - codebuild/**
    - node_modules/**/*.ts
    - node_modules/**/*.d.ts
    - node_modules/**/test/*
    - node_modules/**/tests/*
    - node_modules/chokidar/**
    - node_modules/fsevents/**
    - "node_modules/@tradle/gen-samples/**"
    - npm-shrinkwrap.json

custom:
  vars: ${{file(./vars.yml), file(./default-vars.yml)}}
  defaults: ${{file(./default-vars.yml)}}
  # move these to vars.yml when this issue is fixed:
  #   https://github.com/serverless/serverless/issues/3740
  service: ${{self:custom.vars.service, self:custom.defaults.service}}
  stage: ${{opt:stage, self:custom.vars.stage, self:custom.defaults.stage}}
  secrets: ${{file(./secrets.yml):${{self:custom.stage}}, self:custom.defaults.secrets}}
  # stage: dev
  region: ${{opt:region, self:custom.vars.region, self:custom.defaults.region}}
  profile: ${{opt:profile, self:custom.vars.profile, self:custom.defaults.profile}}
  stackName: ${{self:service}}-${{self:custom.stage}}
  versionFunctions: ${{self:custom.vars.versionFunctions, self:custom.defaults.versionFunctions}}


  blockchain: ${{self:custom.vars.blockchain, self:custom.defaults.blockchain}}
  corda: ${{self:custom.vars.corda, self:custom.defaults.corda}}
  # providerConf: &providerConf
  #   ${{file(./src/in-house-bot/conf/provider.json)}}
  org: ${{self:custom.vars.org, self:custom.defaults.org}}

  # logging: ${{self:custom.vars.logging, self:custom.defaults.logging}}

  # copied from vars.yml
  # emailForNotifications: ${{self:custom.vars.emailForNotifications}}
  # blockchain: ${{self:custom.vars.blockchain}}
  # thresholdBillingAlarm: ${{self:custom.vars.thresholdBillingAlarm, self:custom.defaults.thresholdBillingAlarm}}
  thresholdThrottlingAlarm: ${{self:custom.vars.thresholdThrottlingAlarm, self:custom.defaults.thresholdThrottlingAlarm}}
  thresholdErrorsAlarm: ${{self:custom.vars.thresholdErrorsAlarm, self:custom.defaults.thresholdErrorsAlarm}}
  thresholdInvocationsAlarm: ${{self:custom.vars.thresholdInvocationsAlarm, self:custom.defaults.thresholdInvocationsAlarm}}
  thresholdDurationAlarm: ${{self:custom.vars.thresholdDurationAlarm, self:custom.defaults.thresholdDurationAlarm}}

  # stage: ${{opt:stage, self:custom.vars.stage, self:custom.defaultStage}}
  # region: ${{opt:region, self:custom.vars.region}}

  # prefixes
  prefix: ${{self:service}}-${{self:custom.stage}}-
  regionalPrefix: ${{self:service}}-${{self:custom.stage}}-${{self:custom.region}}-
  prefixRole: ${{self:custom.prefix}}
  # maybe during info/auth, the server can send back the prefix
  # prefixIOTTopic: ${{self:service}}-
  iotParentTopic: ${{self:custom.stackName}}
  iotClientIdPrefix: ${{self:custom.stackName}}-
  prefixSNSTopic: ${{self:custom.prefix}}
  prefixSQS: ${{self:custom.prefix}}
  # apigateway
  # adhere to serverless framework format
  apiGateway: ${{self:custom.stage}}-${{self:service}}

  # versions
  versionSQL: "2016-03-23"
  emailForNotifications:
    ${{self:custom.vars.emailForNotifications, self:custom.defaults.emailForNotifications}}

  # sns
  # billingAlarmTopic: ${{self:custom.prefixSNSTopic}}BillingAlarmNotification
  # throttlingAlarmTopic: ${{self:custom.prefixSNSTopic}}ThrottlingAlarmNotification
  # invocationsAlarmTopic: ${{self:custom.prefixSNSTopic}}InvocationAlarmNotification
  # invocationErrorsAlarmTopic: ${{self:custom.prefixSNSTopic}}InvocationErrorsAlarmNotification

  alertNotifications:
    - protocol: email
      endpoint:
        Fn::FindInMap: ["org", "contact", "adminEmail"]

  alerts:
    stages:
      - dev
    dashboards: true
    topics:
      # ok:
      #   topic: ${{self:custom.prefix}}alerts-ok
      #   notifications: ${{self:custom.alertNotifications}}
      alarm:
        topic: ${{self:custom.prefix}}alerts-alarm
        notifications: ${{self:custom.alertNotifications}}
      # insufficientData:
      #   topic: ${{self:custom.prefix}}alerts-insufficientData
      #   notifications: ${{self:custom.alertNotifications}}
    definitions:
      functionErrors:
        period: 60
        threshold: ${{self:custom.thresholdErrorsAlarm}}
      functionThrottles:
        period: 60
        threshold: ${{self:custom.thresholdThrottlingAlarm}}
      functionInvocations:
        period: 60
        threshold: ${{self:custom.thresholdInvocationsAlarm}}
      functionDuration:
        period: 60
        threshold: ${{self:custom.thresholdDurationAlarm}}
    alarms:
      # - functionErrors
      # - functionThrottles
      # - functionInvocations
      # - functionDuration

  # sqs
  deadLetterQueueName: ${{self:custom.prefixSQS}}dead-letter-queue

  tables:
    # presence: ${{self:custom.prefix}}presence
    # seals: ${{self:custom.prefix}}seals
    # pubkeys: ${{self:custom.prefix}}pubkeys
    # messages: ${{self:custom.prefix}}messages
    events: ${{self:custom.prefix}}events
    # pushsubscribers: ${{self:custom.prefix}}pushsubscribers
    # users: ${{self:custom.prefix}}users
    # friends: ${{self:custom.prefix}}friends
    # conf: ${{self:custom.prefix}}conf
    # kv: ${{self:custom.prefix}}kv
    # backlinks: ${{self:custom.prefix}}backlinks

  # auto-scaled tables that serve as buckets for multiple models each
  defaultCapacityRead: &defaultCapacityRead
    read:
      minimum: 5        # Minimum read capacity
      maximum: 100      # Maximum read capacity
      usage: 0.70       # Targeted usage percentage

  defaultCapacityWrite: &defaultCapacityWrite
    write:
      minimum: 5        # Minimum read capacity
      maximum: 100      # Maximum read capacity
      usage: 0.5        # Targeted usage percentage

  defaultCapacity: &defaultCapacity
    <<: *defaultCapacityRead
    <<: *defaultCapacityWrite

  tableBuckets:
    count: 1
    read:
      minimum: 10       # Minimum read capacity
      maximum: 500      # Maximum read capacity
      usage: 0.70       # Targeted usage percentage
    write:
      minimum: 10       # Minimum read capacity
      maximum: 500      # Maximum write capacity
      usage: 0.5        # Targeted usage percentage

  dynamodb-autoscaling:
    role: AutoScalingDynamoDBRole
    capacities:
      # - table: Bucket0Table
      #   index:
      #     - _dcounterparty
      #     - _link
      #     # - _payloadLink
      #     - _payloadType
      #     - context
      #   read:
      #     minimum: 10       # Minimum read capacity
      #     maximum: 100      # Maximum read capacity
      #     usage: 0.70       # Targeted usage percentage
      #   write:
      #     minimum: 5        # Minimum write capacity
      #     maximum: 100      # Maximum write capacity
      #     usage: 0.5        # Targeted usage percentage

      - table: EventsTable
        write:
          minimum: 5        # Minimum write capacity
          maximum: 100      # Maximum write capacity
          usage: 0.5        # Targeted usage percentage

  cors:
    origin: '*'
    headers:
      - Content-Type
      - X-Amz-Date
      - Authorization
      - X-Api-Key
      - X-Amz-Security-Token
      - X-Amz-User-Agent
      - X-Tradle-Sig
      - X-Tradle-Auth
      - cache
    allowCredentials: false

  serverless-offline: ${{self:custom.vars.serverless-offline, self:custom.defaults.serverless-offline}}
  serverless-iot-local: ${{self:custom.vars.serverless-iot-local, self:custom.defaults.serverless-iot-local}}
  # reinitializeOnConfChanged: ${{self:custom.vars.reinitializeOnConfChanged, self:custom.defaults.reinitializeOnConfChanged}}

  # serverless-dynamodb-local settings
  dynamodb:
    start:
      port: 4569
      # migrate: true
      inMemory: true
      # use dockerized dynamodb from localstack
      noStart: true

  # serverless-s3-local settings
  s3:
    host: 0.0.0.0
    port: 4572
    # directory: /tmp
    buckets:
      - ${{self:custom.prefix}}objectsbucket
      - ${{self:custom.prefix}}secretsbucket
      - ${{self:custom.prefix}}privateconfbucket
      # - ${{self:custom.prefix}}publicconfbucket
      # - ${{self:custom.prefix}}contentaddressedbucket
      - ${{self:custom.prefix}}fileuploadbucket
    cors: false
    # use dockerized s3 from localstack
    noStart: true
    create: false

  # s3-encryption:
  #   buckets:
  #     SecretsBucket:
  #       SSEAlgorithm: AES256

  logRetentionInDays: 7

  issue2233WorkaroundKey: issue2233WorkaroundKey-${{self:service}}-${{self:provider.stage}}
  defaultKMSKeyId: ${{self:custom.regionalPrefix}}default-key

#   secrets: ${{file(secrets.${opt:stage, self:provider.stage}}.yml)}
  # dynamodb:
  #   start:
  #     port: 8000
  #     inMemory: true
  #     migration: true
  #   migration:
  #     dir: offline/migrations

provider:
  # avoid some bugs in serverless
  versionFunctions: ${{self:custom.versionFunctions}}
  tracing: true
  # https://github.com/serverless/serverless/issues/4312#issuecomment-331946882
  variableSyntax: "\\${{([ ~:a-zA-Z0-9._\\'\",\\-\\/\\(\\)]+?)}}"
  name: aws
  runtime: nodejs8.10
  nodeVersion: 'v8.10.0'
  profile: ${{self:custom.profile}}
  stage: ${{self:custom.stage}}
  region: ${{self:custom.region}}
  removeOldDeployments: false
  memorySize: 512
  timeout: 60
  # deploymentBucket: io.tradle.${{self:custom.stage}}.deploys
  environment:
    # enable long stack traces
    BLUEBIRD_DEBUG: 1
    # IOT_TOPIC_PREFIX: ${{self:custom.prefixIOTTopic}}
    IOT_PARENT_TOPIC: ${{self:custom.iotParentTopic}}
    IOT_CLIENT_ID_PREFIX: ${{self:custom.iotClientIdPrefix}}
    BLOCKCHAIN: ${{self:custom.blockchain}}
    CORDA_API_URL: ${{self:custom.corda.apiUrl}}
    CORDA_API_KEY: ${{self:custom.corda.apiKey}}
    DEBUG: '*lambda*,tradle*,-@tradle/dynamodb'
    DEBUG_LEVEL: ${{self:custom.vars.debug.level, self:custom.defaults.debug.level}}
    DEBUG_FORMAT: ${{self:custom.vars.debug.format, self:custom.defaults.debug.format}}
    SERVERLESS_PREFIX: ${{self:custom.prefix}}
    SERVERLESS_STAGE: ${{self:custom.stage}}
    SERVERLESS_SERVICE_NAME: ${{self:service}}
    NO_TIME_TRAVEL: false # allow time-travel messages for now

  apiKeys:
    - ${{self:custom.issue2233WorkaroundKey}}

  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:CreateTable
        - dynamodb:DescribeTable
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
        - dynamodb:BatchWriteItem
        - dynamodb:DescribeStream
        - dynamodb:GetRecords
        - dynamodb:GetShardIterator
        - dynamodb:ListStreams
      Resource:
        - Fn::Sub: 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${{self:custom.prefix}}*'

    - Effect: Allow
      Action:
        # so lambdas can list resources in their stack
        - cloudformation:ListStackResources
        # need to get own template to generate a child deployment template
        - cloudformation:GetTemplate
      Resource: ["*"]

    # allow lambdas to update themselves
    - Effect: Allow
      Action:
        - lambda:UpdateFunctionConfiguration
        - lambda:ListFunctions
      # This action does not support resource-level permissions
      Resource: ["*"]

    - Effect: Allow
      Action:
        - lambda:GetFunctionConfiguration
      Resource:
        - Fn::Sub: 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${{self:custom.prefix}}*'

    # allow access to bucket
    # TODO: give access only to the lambdas that need it
    - Effect: Allow
      Action:
        # needed to get NoSuchKey error instead of AccessDenied for non-existent items
        # https://forums.aws.amazon.com/thread.jspa?threadID=56531
        - s3:ListBucket
        # # needed to enable bucket encryption
        # - s3:PutEncryptionConfiguration
      Resource:
        # - arn:aws:s3:::${{self:provider.deploymentBucket}}
        # - Fn::Join:
        #   - ""
        #   - - "arn:aws:s3:::"
        #     - Ref: PublicConfBucket
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: PrivateConfBucket
        # - Fn::Join:
        #   - ""
        #   - - "arn:aws:s3:::"
        #     - Ref: ContentAddressedBucket
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: ObjectsBucket
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: SecretsBucket
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: ServerlessDeploymentBucket
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: FileUploadBucket

    - Effect: Allow
      Action:
        - s3:PutObject
        # needed to create an object with public-read
        - s3:PutObjectAcl
        - s3:GetObject
        # needed to check existence
        - s3:HeadObject
      Resource:
        # - arn:aws:s3:::${{self:provider.deploymentBucket}}/*
        # - Fn::Join:
        #   - ""
        #   - - "arn:aws:s3:::"
        #     - Ref: PublicConfBucket
        #     - "/*"
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: PrivateConfBucket
            - "/*"
        # - Fn::Join:
        #   - ""
        #   - - "arn:aws:s3:::"
        #     - Ref: ContentAddressedBucket
        #     - "/*"
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: ObjectsBucket
            - "/*"
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: SecretsBucket
            - "/*"
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: ServerlessDeploymentBucket
            - "/*"
        - Fn::Join:
          - ""
          - - "arn:aws:s3:::"
            - Ref: FileUploadBucket
            - "/*"

    # REMOVE in prod
    # allow access to buckets from the console
    - Effect: Allow
      Action:
        - s3:GetBucketLocation
        - s3:ListAllMyBuckets
      Resource: "arn:aws:s3:::*"

    # allow lambdas to call each other
    # TODO: make this more fine grained
    - Effect: Allow
      Action:
        - lambda:InvokeFunction
        - lambda:InvokeAsync
      Resource: "*"

    # Iot
    - Effect: Allow
      Action: ["iot:Connect", "iot:Subscribe", "iot:Publish", "iot:Receive", "iot:DescribeEndpoint"]
      Resource: ["*"]

    # gen Iot temp credentials (lambda: preauth)
    - Effect: Allow
      Action:
        - sts:AssumeRole
      Resource:
        - Fn::GetAtt:
          - IotClientRole
          - Arn
    - Effect: Allow
      Action:
        - xray:PutTraceSegments
        - xray:PutTelemetryRecords
      Resource: "*"
    - Effect: Allow
      Sid: AllowCloudFrontUpdateDistribution
      Action:
        - cloudfront:updateDistribution
      Resource: ["*"]

    # - Effect: Allow
    #   Action:
    #     - apigateway:GET
    #     - apigateway:PUT
    #   Resource:
    #     Fn::Join:
    #       - ""
    #       - - "arn:aws:apigateway:"
    #         - Ref: AWS::Region
    #         - "::/restapis/"
    #         - Ref: ApiGatewayRestApi
    #         - "/*"

    # - Effect: Allow
    #   Action:
    #     - apigateway:POST
    #   Resource:
    #     Fn::Join:
    #       - ""
    #       - - "arn:aws:apigateway:"
    #         - Ref: AWS::Region
    #         - "::/restapis/"
    #         - Ref: ApiGatewayRestApi

    - Effect: Allow
      Action:
        - ses:SendEmail
        - ses:SendRawEmail
        - ses:GetIdentityVerificationAttributes
      Resource: "*"

    # - Effect: Allow
    #   Action:
    #     - 'ssm:GetParameter*'
    #     - 'ssm:PutParameter*'
    #   Resource:
    #     - 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/tradle/${{self:custom.prefix}}*'

functions:
  # warm up other functions
  warmup:
    handler: lib/in-house-bot/lambda/warmup.handler
    memorySize: 128
    events:
      - schedule:
          rate: rate(5 minutes)
          enabled: true
          input:
            concurrency: 5
            functions:
              - oniotlifecycle
              - onmessage
              - onresourcestream
              - graphql
              - info
              - preauth
              - auth
              - inbox
    alarms:
      - functionErrors
      # - functionThrottles
      - functionInvocations

  # 1. generates temporary credentials (STS) for new connections,
  #    and assumes IotClientRole on them
  # 2. creates an unauthenticated session,
  #    generates a challenge to be signed (verified in /auth)
  preauth:
    handler: lib/in-house-bot/lambda/http/preauth.handler
    memorySize: 1024
    events:
      - http:
          path: preauth
          method: post
          cors: ${{self:custom.cors}}

  # 1. validates the challenge response
  # 2. marks the session as authenticated
  auth:
    handler: lib/in-house-bot/lambda/http/auth.handler
    memorySize: 1024
    events:
      - http:
          path: auth
          method: post
          cors: ${{self:custom.cors}}

  inbox:
    handler: lib/in-house-bot/lambda/http/inbox.handler
    memorySize: 1024
    events:
      - http:
          path: inbox
          method: put
          cors: ${{self:custom.cors}}
      - http:
          path: inbox
          method: post
          cors: ${{self:custom.cors}}

  delivery-retry:
    handler: lib/in-house-bot/lambda/delivery-retry.handler
    memorySize: 128
    timeout: 60
    events:
      - schedule:
          rate: rate(1 minute)
          enabled: true

  # triggered when an internal bot requests a message range (inbound messages)
  # inbox:
  #   handler: lib/lambda/inbox.handler
  #   memorySize: 1024
  #   events:
  #     - iot:
  #         sql: "SELECT * as data, topic() as topic FROM 'messages/get'"

  # triggered when a client requests a message range (outbound messages)
  # outbox:
  #   handler: lib/lambda/outbox.handler
  #   memorySize: 1024
  #   events:
  #     - iot:
  #         sql: "SELECT * as data, topic() as topic FROM '+/restore'"

  #   environment:
  #     DEBUG: tradle:*

  # handles IoT (MQTT) connections post-authentication
  # updates presence in PresenceTable

  oniotlifecycle:
    handler: lib/in-house-bot/lambda/mqtt/oniotlifecycle.handler
    events:
      - iot:
          sql: "SELECT * as data, topic() as topic FROM '$aws/events/presence/connected/#' WHERE startswith(clientId, '${{self:custom.iotClientIdPrefix}}')"
          sqlVersion: ${{self:custom.versionSQL}}
      - iot:
          sql: "SELECT * as data, topic() as topic FROM '$aws/events/presence/disconnected/#' WHERE startswith(clientId, '${{self:custom.iotClientIdPrefix}}')"
          sqlVersion: ${{self:custom.versionSQL}}
      - iot:
          sql: "SELECT * as data, topic() as topic FROM '$aws/events/subscriptions/subscribed/#' WHERE startswith(clientId, '${{self:custom.iotClientIdPrefix}}')"
          sqlVersion: ${{self:custom.versionSQL}}
    alarms:
      - functionErrors
      - functionThrottles
      - functionInvocations

  # onconnect:
  #   handler: lib/in-house-bot/lambda/mqtt/onconnect.handler
  #   events:
  #     - iot:
  #         sql: "SELECT * FROM '$aws/events/presence/connected/#'"
  #         sqlVersion: ${{self:custom.versionSQL}}
  #   alarms:
  #     - functionErrors
  #     - functionThrottles
  #     - functionInvocations

  # triggered when a client sends a message
  #
  # validates, stores in MessagesTable, in ObjectsBucker (for now),
  # and passes off to bot engine
  onmessage:
    handler: lib/in-house-bot/lambda/mqtt/onmessage.handler
    memorySize: 1024
    #   SERVERLESS_PREFIX: ${{self:custom.prefix}}
    #   SERVERLESS_STAGE: ${{self:custom.stage}}
    #   SERVERLESS_SERVICE_NAME: ${{self:service}}
    events:
      - iot:
          sql: "SELECT encode(*, 'base64') as data, clientid() as clientId, topic() as topic FROM '${{self:custom.iotParentTopic}}/+/pub/outbox'"
          sqlVersion: ${{self:custom.versionSQL}}
    alarms:
      - functionErrors
      - functionThrottles
      - functionInvocations

  # same as onmessage, but can handle larger payloads
  # MQTT is limited to 128KB, HTTP to 6MB
  # onmessage_http:
  #   handler: lib/in-house-bot/lambda/http/onmessage.handler
  #   memorySize: 1024
  #   events:
  #     - http:
  #         path: message
  #         method: put
  #     - http:
  #         path: message
  #         method: post
  #   alarms:
  #     - functionErrors
  #     - functionThrottles
  #     - functionInvocations

  # performs service discovery - builds a map of logical->physical ids
  # and writes that map to the environment variables of all other lambdas
  # setenvvars:
  #   handler: lib/lambda/setenvvars.handler
  #   # hack to enable discovery own function's own stack
  #   description:
  #     Ref: AWS::StackId

  # initializes provider identity
  # generates a new identity and keys, and other misc crap
  # init:
  #   handler: lib/lambda/init.handler
  #   memorySize: 256
  #   timeout: 300
  #   alarms:
  #     - functionErrors
  #     - functionThrottles
  #     - functionInvocations

  # setstyle:
  #   handler: lib/lambda/setstyle.handler
  #   memorySize: 128
  #   alarms:
  #     - functionErrors
  #     - functionThrottles
  #     - functionInvocations

  # precreate-tables:
  #   handler: lib/lambda/precreate-tables.handler
  #   memorySize: 128
  #   timeout: 300

  # Blockchain

  # bitcoin faucet (surprise!)
  # distributes testnet coins from local funds
  # faucet_bitcoin:
  #   handler: lib/lambda/faucet-bitcoin.withdraw

  # gets funds from a bitcoin testnet faucet
  # recharge_bitcoin:
  #   handler: lib/lambda/recharge-bitcoin.handler
  #   events:
  #     - schedule:
  #         rate: rate(10 minutes)
  #         enabled: false

  # get funds from ethereum testnet faucet
  # (doesn't work on rinkeby, and doesn't work well on ropsten)
  # recharge_ethereum:
  #   handler: lib/lambda/recharge-ethereum.handler
  #   events:
  #     - schedule:
  #         rate: rate(10 minutes)
  #         enabled: false

  # writes pending transactions to the blockchain
  sealpending:
    handler: lib/in-house-bot/lambda/sealpending.handler
    memorySize: 256
    timeout: 300
    events:
      - schedule:
          rate: rate(10 minutes)
          # enabled: false
    alarms:
      - functionErrors
      # - functionThrottles
      # - functionInvocations

  # polls the status of unconfirmed blockchain transactions
  pollchain:
    handler: lib/in-house-bot/lambda/pollchain.handler
    memorySize: 256
    timeout: 300
    events:
      - schedule:
          rate: rate(10 minutes)
          # enabled: false
    alarms:
      - functionErrors
      # - functionThrottles
      # - functionInvocations

    # environment:
    #   ENCRYPTION_KEY: ${{self:custom.secrets.SESSION_KEY}}
    #   EMAIL_SERVICE_API_KEY: ${{self:custom.secrets.EMAIL_SERVICE_API_KEY}}

  check-failed-seals:
    handler: lib/in-house-bot/lambda/check-failed-seals.handler
    memorySize: 256
    timeout: 60
    events:
      - schedule:
          rate: rate(17 minutes)
          # enabled: false
    alarms:
      - functionErrors

  # force reinitialize lambda containers
  reinitialize-containers:
    handler: lib/in-house-bot/lambda/reinitialize-containers.handler

  # useful during development
  # trigger a message to be queued/sent to a user
  # send:
  #   handler: lib/in-house-bot/lambda/send.handler
  #   memorySize: 256

  info:
    handler: lib/in-house-bot/lambda/http/info.handler
    memorySize: 256
    events:
      - http:
          path: info
          method: get
          cors: ${{self:custom.cors}}

  # rename later, temporarily can't rename, get AWS error:
  #   "Modifying service token is not allowed..""
  bot_oninit:
    handler: lib/in-house-bot/lambda/oninit.handler
    memorySize: 1024

  # onsealstream:
  #   handler: lib/in-house-bot/lambda/onsealstream.handler
  #   memorySize: 256
  #   events:
  #     - stream:
  #         type: dynamodb
  #         batchSize: 1
  #         startingPosition: TRIM_HORIZON
  #         arn:
  #           Fn::GetAtt:
  #             - SealsTable
  #             - StreamArn
  #   alarms:
  #     - functionErrors

  # onmessagestream:
  #   handler: lib/in-house-bot/lambda/onmessagestream.handler
  #   memorySize: 256
  #   events:
  #     - stream:
  #         type: dynamodb
  #         batchSize: 100
  #         startingPosition: TRIM_HORIZON
  #         arn:
  #           Fn::GetAtt:
  #             - MessagesTable
  #             - StreamArn
  #   alarms:
  #     - functionErrors
  #     # - functionThrottles
  #     # - functionInvocations
  #   # onError:
  #     # Ref: DeadLetterQueue

  onresourcestream:
    handler: lib/in-house-bot/lambda/onresourcestream.handler
    memorySize: 256
    events:
      - stream:
          type: dynamodb
          batchSize: 20
          startingPosition: TRIM_HORIZON
          arn:
            Fn::GetAtt:
              - Bucket0Table
              - StreamArn
    alarms:
      - functionErrors

  graphql:
    # make sure graphql route gets loaded
    handler: lib/in-house-bot/lambda/http/graphql.handler
    memorySize: 1024
    events:
      - http:
          path: graphql
          method: get
          cors: ${{self:custom.cors}}
      - http:
          path: graphql
          method: post
          cors: ${{self:custom.cors}}
    alarms:
      - functionErrors
      - functionThrottles
      - functionInvocations

  # setstyle:
  #   handler: lib/in-house-bot/lambda/set-style.handler
  #   memorySize: 128

  setconf:
    handler: lib/in-house-bot/lambda/set-conf.handler
    memorySize: 1024

  # addfriend:
  #   handler: lib/in-house-bot/lambda/add-friend.handler
  #   memorySize: 256

  # addfriend_dev:
  #   handler: lib/in-house-bot/lambda/add-friend.handlerHttp
  #   # dev mode only
  #   events:
  #     - http:
  #         path: /addfriend
  #         method: post

  # addcontact:
  #   handler: lib/in-house-bot/lambda/add-contact.handler
  #   environment:
  #     DEBUG: tradle:*

  # bot-serviced lambda
  # generates sample data for browsing with GraphQL
  # samples:
  #   handler: lib/in-house-bot/lambda/samples.handler
  #   memorySize: 1024

  # samples_dev:
  #   handler: lib/in-house-bot/lambda/samples.handler
  #   memorySize: 1024
  #   events:
  #     - http:
  #         path: samples
  #         method: post

  import_data_utils:
    handler: lib/in-house-bot/lambda/import-data-utils.handler

  # import_data_bundle:
  #   handler: lib/in-house-bot/lambda/import-data-bundle.handler

  # create_data_claim:
  #   handler: lib/in-house-bot/lambda/create-data-claim.handler

  # get_data_bundle:
  #   handler: lib/in-house-bot/lambda/get-data-bundle.handler

  onfido_register:
    handler: lib/in-house-bot/lambda/onfido-register.handler

  onfido:
    handler: lib/in-house-bot/lambda/http/onfido-webhook.handler
    memorySize: 1024
    events:
      - http:
          path: onfido
          method: post
          cors: ${{self:custom.cors}}

  # documentChecker:
  #   handler: lib/in-house-bot/lambda/http/documentChecker-webhook.handler
  #   memorySize: 1024
  #   events:
  #     - http:
  #         path: documentChecker
  #         method: post
  #         cors: ${{self:custom.cors}}

  documentChecker:
    handler: lib/in-house-bot/lambda/document-checker-job.handler
    memorySize: 128
    timeout: 60
    events:
      - schedule:
          rate: rate(1 minute)
          enabled: true

  cli:
    handler: lib/in-house-bot/lambda/cli.handler
    timeout: 300

  qr:
    handler: lib/in-house-bot/lambda/http/qr.handler
    events:
      - http:
          path: qr
          method: get
          cors: ${{self:custom.cors}}

  deployment_pingback:
    handler: lib/in-house-bot/lambda/http/deployment-pingback.handler
    events:
      - http:
          path: deployment-pingback
          method: post
          cors: ${{self:custom.cors}}

  confirmation:
    handler: lib/in-house-bot/lambda/http/confirmation.handler
    events:
      - http:
          path: confirmation
          method: get
          cors: ${{self:custom.cors}}

  # webhooks:
  #   handler: lib/in-house-bot/lambda/webhooks.handler
  #   memorySize: 256
  #   events:
  #     - stream:
  #         type: dynamodb
  #         batchSize: 100
  #         startingPosition: TRIM_HORIZON
  #         arn:
  #           Fn::GetAtt:
  #             - MessagesTable
  #             - StreamArn
  #     - stream:
  #         type: dynamodb
  #         batchSize: 100
  #         startingPosition: TRIM_HORIZON
  #         arn:
  #           Fn::GetAtt:
  #             - SealsTable
  #             - StreamArn
  #     - stream:
  #         type: dynamodb
  #         batchSize: 100
  #         startingPosition: TRIM_HORIZON
  #         arn:
  #           Fn::GetAtt:
  #             - UsersTable
  #             - StreamArn
  #     # + streams from bucket tables

  # cli_dev:
  #   handler: lib/in-house-bot/lambda/cli.handler
  #   # dev mode only
  #   events:
  #     - http:
  #         path: cli
  #         method: post

  # bash:
  #   handler: lib/in-house-bot/lambda/bash.handler

resources:
  Mappings:
    org:
      init: ${{self:custom.org}}
      contact:
        adminEmail: ${{self:custom.emailForNotifications}}

    deployment:
      init:
        service: ${{self:service}}
        stage: ${{self:custom.stage}}
        stackName: ${{self:custom.stackName}}
        # encryptionKey:
        # which MyCloud generated the template
        referrerUrl: ''
        deploymentUUID: ''

  Resources:
    ApiGatewayRestApi:
      Type: AWS::ApiGateway::RestApi
      Properties:
        Name: ${{self:custom.apiGateway}}
        BinaryMediaTypes:
          - "*/*"
        # BinaryMediaTypes: ${{self:custom.vars.binaryMediaTypes, self:custom.defaults.binaryMediaTypes}}

    # AdminsGroup:
    #   Type: AWS::IAM::Group
    #   Properties:
    #     GroupName: ${{self:custom.regionalPrefix}}admins
    #     Path: '/tradle/${{self:provider.region}}/${{self:provider.stage}}'

    # RestrictedBucketPolicy:
    #   Type: AWS::IAM::Policy
    #   Properties:
    #     PolicyName: ${{self:custom.regionalPrefix}}RestrictedBucketPolicy
    #     Groups:
    #       - Ref: AdminsGroup
    #     Roles:
    #       - Ref: IamRoleLambdaExecution
    #       - Fn::Join:
    #         - ""
    #         - - "arn:aws:sts::${AWS::AccountId}:assumed-role/"
    #           - Ref: IamRoleLambdaExecution
    #           - "/${{self:custom.prefix}}*"
    #     PolicyDocument:
    #       Statement:
    #         - Sid: 'grant admins access to private buckets'
    #           Effect: Allow
    #           Action:
    #             - s3:ListBucket
    #             - s3:GetObject
    #             - s3:HeadObject
    #           Resource:
    #             - Fn::Join:
    #               - ""
    #               - - "arn:aws:s3:::"
    #                 - Ref: SecretsBucket
    #             - Fn::Join:
    #               - ""
    #               - - "arn:aws:s3:::"
    #                 - Ref: SecretsBucket
    #                 - "/*"
    #             - Fn::Join:
    #               - ""
    #               - - "arn:aws:s3:::"
    #                 - Ref: PrivateConfBucket
    #             - Fn::Join:
    #               - ""
    #               - - "arn:aws:s3:::"
    #                 - Ref: PrivateConfBucket
    #                 - "/*"

  #   cors:
  #     origin: '*'
  #     headers:
  #       - Content-Type
  #       - X-Amz-Date
  #       - Authorization
  #       - X-Api-Key
  #       - X-Amz-Security-Token
  #       - X-Amz-User-Agent
  #       - X-Tradle-Sig
  #       - cache

    # servless-framework-generated API Gateway
    # ApiGatewayStage:
    #   Type: AWS::ApiGateway::Stage
    #   Properties:
    #     MethodSettings:
    #       - DataTraceEnabled: true
    #         HttpMethod: "*"
    #         LoggingLevel: INFO
    #         ResourcePath: "/*"
    #         MetricsEnabled: true

    # DefaultBucketPolicy:

    #   "Sid": "DenyPublicListACL",
    #   "Effect": "Deny",
    #   "Principal": {
    #     "AWS": "*"
    #   },
    #   "Action": "s3:PutBucketAcl",
    #   "Resource": "arn:aws:s3:::examplebucket",
    #   "Condition": {
    #     "StringEquals": {
    #       "s3:x-amz-acl": [
    #         "public-read",
    #         "public-read-write",
    #         "authenticated-read"
    #       ]
    #     }
    #   }

    # content-addressed storage
    # stores message payloads (message minus envelope)
    # may be going away soon
    ObjectsBucket:
      Type: AWS::S3::Bucket
      Description: content-addressed storage for all objects
      DeletionPolicy: Retain

    # stores identity keys
    SecretsBucket:
      Type: AWS::S3::Bucket
      Description: stuff
      DeletionPolicy: Retain
      Properties:
        VersioningConfiguration:
          Status: Enabled
        # PolicyDocument:
        #   Id: ${{self:custom.regionalPrefix}}SecretsBucketPolicy
        #   Version: '2012-10-17'
        #   Statement:
        #     - Sid: 'deny access to bucket'
        #       Effect: Deny
        #       Resource: '*'
        #       Action:
        #         - 's3:*'
        #       Principal:
        #         AWS: "*"

              # NotPrincipal:
              #   AWS:
              #     - Fn::Sub: 'arn:aws:iam::${AWS::AccountId}:root'
              #     - Fn::GetAtt:
              #       - IamRoleLambdaExecution
              #       - Arn
              #     - Fn::Join:
              #       - ''
              #       - - "arn:aws:iam::${AWS::AccountId}:assumed-role/"
              #         - Ref: IamRoleLambdaExecution
              #         - "/*"

        # Bucket:
        #   Ref: SecretsBucket

        # Uncomment when the CloudFormation issues with BucketEncryption are resolved
        # BucketEncryption:
        #   ServerSideEncryptionConfiguration:
        #     - ServerSideEncryptionByDefault:
        #         SSEAlgorithm: AES256

    PrivateConfBucket:
      Type: AWS::S3::Bucket
      Description: private configuration files
      DeletionPolicy: Retain
      Properties:
        VersioningConfiguration:
          Status: Enabled

    # stores media uploaded by users
    FileUploadBucket:
      Type: AWS::S3::Bucket
      Description: file upload destination for all users
      DeletionPolicy: Retain
      Properties:
        CorsConfiguration:
          CorsRules:
            - AllowedMethods:
                - GET
                - PUT
                - POST
              AllowedOrigins:
                - "*"
              AllowedHeaders:
                - "*"
              MaxAge: 3600

    FileUploadBucketPolicy:
      Type: AWS::S3::BucketPolicy
      Properties:
        Bucket:
          Ref: FileUploadBucket
        PolicyDocument:
          Id: FileUploadBucketPolicy
          Version: '2012-10-17'
          Statement:
          - Sid: PutAccess
            Action:
            - s3:PutObject
            Effect: Allow
            Resource:
              - Fn::Join:
                - ""
                - - "arn:aws:s3:::"
                  - Ref: FileUploadBucket
                  - /
                  # ${aws:userid} will change on every session
                  # which will prevent users from clobbering old uploads
                  - ${aws:userid}
                  - "/*"
            Principal:
              AWS:
                Fn::GetAtt:
                  - IotClientRole
                  - Arn

    # EventsTable: ${{file(./conf/table/events.yml)}}

    # master log from which things can be rebuilt
    # in case of schema changes, disasters, etc.
    EventsTable:
      Type: AWS::DynamoDB::Table
      Description: source of truth
      Properties:
        TableName: ${{self:custom.tables.events}}
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        ProvisionedThroughput:
          ReadCapacityUnits: 5
          WriteCapacityUnits: 5
        # StreamSpecification:
        #   StreamViewType: NEW_IMAGE
          # StreamViewType: NEW_AND_OLD_IMAGES

    # role assumed by all IoT clients
    IotClientRole:
      Type: AWS::IAM::Role
      Description: role assumed by every connecting client
      Properties:
        RoleName: ${{self:custom.prefixRole}}IotClientRole
        AssumeRolePolicyDocument:
          Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Principal:
                Service:
                  - lambda.amazonaws.com
                AWS:
                  - Fn::Sub: 'arn:aws:iam::${AWS::AccountId}:root'
                  # would be nice to use the below Fn::GetAtt
                  # but it creates a circular dep
                  # - Fn::Sub: 'arn:aws:iam::${AWS::AccountId}:role/${{self:custom.prefix}}${{self:provider.region}}-lambdaRole'
                  # - Fn::GetAtt:
                  #   - IamRoleLambdaExecution
                  #   - Arn
              Action:
                - sts:AssumeRole
        Policies:
          - PolicyName: ${{self:custom.regionalPrefix}}IotClientRole
            PolicyDocument:
              Version: "2012-10-17"
              Statement:
                # - Effect: Allow
                #   Action:
                #     - dynamodb:*
                #   Resource:
                #     - Fn::Sub: 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/Bucket0Table'
                - Effect: Allow
                  Action:
                    - logs:CreateLogGroup
                    - logs:CreateLogStream
                    - logs:PutLogEvents
                  Resource: arn:aws:logs:::log-group:/aws/lambda/*:*:*
                # restrict client connect by client id
                - Effect: Allow
                  Action: ["iot:Connect"]
                  # Resource: ["*"]
                  Resource:
                    - Fn::Join:
                      - ":"
                      - - 'arn:aws:iot'
                        - Ref: AWS::Region
                        - Ref: AWS::AccountId
                        - 'client/${iot:ClientId}'

                # allow all clients to publish to the send topic
                - Effect: "Allow"
                  Action: ["iot:Publish"]
                  # Resource: ["*"]
                  Resource:
                    - Fn::Join:
                      - ":"
                      - - 'arn:aws:iot'
                        - Ref: AWS::Region
                        - Ref: AWS::AccountId
                        - 'topic/${{self:custom.iotParentTopic}}/${iot:ClientId}/pub/outbox'
                  #   - arn:aws:iot:::topic/${{self:custom.prefixIOTTopic}}message
                  #   - arn:aws:iot:::topic/${{self:custom.prefixIOTTopic}}restore

                # restrict client topic subscriptions by their client id
                - Effect: "Allow"
                  Action: ["iot:Subscribe"]
                  # Resource: ["*"]
                  Resource:
                    - Fn::Join:
                      - ":"
                      - - 'arn:aws:iot'
                        - Ref: AWS::Region
                        - Ref: AWS::AccountId
                        - 'topicfilter/${{self:custom.iotParentTopic}}/${iot:ClientId}/sub/*'
                # restrict messages clients receive by their client id
                # this has the same function as the Subscribe rule above
                # provided the Subscribe policy is upheld, this policy should always give a pass
                - Effect: "Allow"
                  Action: ["iot:Receive"]
                  Resource:
                    - Fn::Join:
                      - ":"
                      - - 'arn:aws:iot'
                        - Ref: AWS::Region
                        - Ref: AWS::AccountId
                        - 'topic/${{self:custom.iotParentTopic}}/${iot:ClientId}/sub/*'

    AutoScalingDynamoDBRole:
      Type: AWS::IAM::Role
      Properties:
        AssumeRolePolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Principal:
                Service:
                  - application-autoscaling.amazonaws.com
              Action:
                - sts:AssumeRole
        Path: "/"
        Policies:
          - PolicyName: ${{self:custom.regionalPrefix}}AutoScalingDynamoDBPolicy
            PolicyDocument:
              Version: '2012-10-17'
              Statement:
                - Effect: Allow
                  Action:
                    - dynamodb:DescribeTable
                    - dynamodb:UpdateTable
                  Resource:
                    - Fn::Join:
                        - ""
                        - - "arn:aws:dynamodb:"
                          - Ref: AWS::Region
                          - ":*:table/${{self:custom.prefix}}*"
                - Effect: Allow
                  Action:
                    - cloudwatch:DescribeAlarms
                    - cloudwatch:PutMetricAlarm
                    - cloudwatch:DeleteAlarms
                  Resource: "*"

    Initialize:
      Type: Custom::InitializeDeployment
      DependsOn: ApiGatewayApiKey1
      Properties:
        ServiceToken:
          Fn::GetAtt: [BotUnderscoreoninitLambdaFunction, Arn]
        name:
          Fn::FindInMap: ["org", "init", "name"]
        domain:
          Fn::FindInMap: ["org", "init", "domain"]
        logo:
          Fn::FindInMap: ["org", "init", "logo"]
        deploymentUUID:
          Fn::FindInMap: ["deployment", "init", "deploymentUUID"]
        referrerUrl:
          Fn::FindInMap: ["deployment", "init", "referrerUrl"]
        # encryptionKey:
        #   Fn::FindInMap: ["deployment", "init", "encryptionKey"]

          # <<: *providerConf

    DefaultEncryptionKey:
      Type: AWS::KMS::Key
      Properties:
        Description: 'Encryption key for secrets in SSM'
        Enabled: True
        EnableKeyRotation: False
        Tags:
          - Key: tradle
            Value: ${{self:custom.stackName}}-${{self:provider.region}}

        KeyPolicy:
          Version: '2012-10-17'
          Id: ${{self:custom.defaultKMSKeyId}}-policy
          Statement:
            - Sid: 'Allow access for Key Administrators'
              Effect: Allow
              Principal:
                AWS:
                  - Fn::Sub: 'arn:aws:iam::${AWS::AccountId}:root'
              Action:
                - 'kms:Create*'
                - 'kms:Describe*'
                - 'kms:Enable*'
                - 'kms:List*'
                - 'kms:Put*'
                - 'kms:Update*'
                - 'kms:Revoke*'
                - 'kms:Disable*'
                - 'kms:Get*'
                - 'kms:Delete*'
                - 'kms:TagResource'
                - 'kms:UntagResource'
                - 'kms:ScheduleKeyDeletion'
                - 'kms:CancelKeyDeletion'
              Resource: '*'

            - Sid: 'Allow attachment of persistent resources'
              Effect: Allow
              Principal:
                AWS:
                  - Fn::Sub: 'arn:aws:iam::${AWS::AccountId}:root'
              Action:
                - 'kms:CreateGrant'
                - 'kms:ListGrants'
                - 'kms:RevokeGrant'

              # Condition:
              #   ForAllValues:StringEquals:
              #     kms:GrantOperations:
              #       - 'Decrypt'

              # https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms-grant-is-for-aws-resource
              Condition:
                Bool:
                  "kms:GrantIsForAWSResource": true

              Resource: '*'
            - Sid: 'Allow use of the key'
              Effect: Allow
              Principal:
                AWS:
                  - Fn::GetAtt:
                    - IamRoleLambdaExecution
                    - Arn
              Action:
                - 'kms:Decrypt'
                - 'kms:GenerateDataKey'
              Resource: '*'

      # DefaultEncryptionKeyAlias:
      #   Type: AWS::KMS::Alias
      #   Properties:
      #     AliasName: alias/${{self:custom.defaultKMSKeyId}}
      #     TargetKeyId:
      #       Ref: DefaultEncryptionKey
